# 第6章 函数

函数是一个命了名的 **代码块** ，我们通过 **调用函数** 执行相应的代码。函数可以有 **零个或者多个** 参数，而且（通常）会产生一个结果。可以 **重载函数** ，也就是说，同一个名字可以对应几个不同的函数。

## 6.1 函数基础

典型的函数定义包含以下部分：

* 返回类型。
* 函数名。
* 由零个或者多个形参组成的列表。
* 函数体。

每个形参使用逗号隔开，形参的列表位于一对圆括号内。函数执行的操作在语句块中，这个语句块被称为函数体。

通过 **调用运算符（`()`）** 来执行函数。调用运算符的形式是 **一对圆括号** ，该符号作用于一对表达式，该表达式是 **函数名** 或者指向 **函数的指针** ：圆括号里面是一个用逗号隔开的 **实参列表** ， **我们使用实参初始化函数的形参** 。调用表达式的类型就是函数的返回类型。

#### 编写函数

#### 调用函数

函数的调用完成两项工作：首先用 **实参初始化函数对应的形参** ，然后 **将控制权转移给被调用函数** 。这时主调函数的执行被暂时中断，被调函数开始执行。

`return` 语句完成两项工作：返回 `return` 语句中的值（如果有的话），将控制权从被调函数转移回主调函数。函数的返回值用于初始化调用表达式的结果，之后继续完成调用所在的表达式的剩余部分。

#### 形参和实参

**实参是形参的初始值** 。实参初始化位置对应的形参。尽管这种对应关系存在，但是并 **没有规定实参的求值顺序** 。编译器能 **以任意可行的顺序对实参求值** 。

实参的类型必须与对应的形参类型匹配。 **函数有几个形参，我们就必须提供相同数量的实参** 。

#### 函数的形参列表

函数的形参列表可以为空，但是不能省略。要想定义一个不带形参的函数，最常用的办法就是书写一个空的形参列表，当然也可以使用关键字 `void` 表示函数没有形参。

每个形参都必须含有一个类型声明符。

任意两个形参都不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。

形参名是可选的，但是由于我们无法使用未命名的形参，所以形参必须起名。

#### 函数返回类型

返回类型 `void` 表示函数不返回任何值。函数的返回类型 **不能** 是 **数组类型** 或者 **函数类型** ，但是可以是指向函数或者数组的指针。

### 6.1.1 局部对象

名字有作用域，对象有生命周期。

* **名字的作用域** ：程序文本的一部分，名字在其中可见。
* **对象的生命周期** ：程序执行过程中该对象存在的一段时间。

函数体是一个语句块。块构成一个新的作用域，我们可以在其中定义变量。 <u>形参和函数体内部定义的变量统称为 **局部变量**</u> 。它们仅仅在函数的作用域内可见，同时局部变量还会覆盖在外层作用域中同名的其他所有同名的声明。

在所有函数体之外定义的对象存在于程序的整个执行过程之中。此类对象在程序启动时被创建，直到程序结束才会被销毁。局部变量的生命周期依赖于定义的方式。

#### 自动对象

自动对象指的是： **只存在于块执行期间的对象** 。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。

**形参就是一种自动对象** 。函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，所以一旦函数终止，形参也就被销毁。

使用传递给函数的实参初始化形参对应的自动对象。对于局部变量，也就是声明定义在函数体内的变量来说分两种情况：如果变量定义本身含有初始值，就用这个初始值进行初始化；否则，如果变量定义本身不含初始值，执行默认初始化。这里表明： **内置类型的未初始化局部变量将产生未定义的值** 。

#### 局部静态对象

**<u>局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，直到程序终止才被销毁</u>** 。在此期间即使对象所在的函数结束执行也不会对它产生影响。

如果局部静态变量没有显式的初始值，它将执行值初始化， **内置类型的局部静态变量初始化为 `0`** 。

### 6.1.2 函数声明

函数的名字必须在使用前声明。函数只能定义一次，但是可以声明多次。如果一个函数永远不会被用到，那么它可以只有声明没有定义。

函数的声明无须函数体，使用一个分号代替即可。

函数的声明不包含函数体，所以也就无须形参的名字。当然， <u>我们建议 **写出形参的名字** ，它可以帮助使用者或者程序员更好的理解函数的功能</u> 。

函数的三要素（返回类型，函数名，形参类型）描述了函数的 **接口** ，说明了调用该函数所需的全部信息。函数声明也称作 **函数原型** 。

#### 在头文件中进行函数声明

我们建议变量和函数在头文件中声明，在源文件中定义。

含有函数声明的头文件应该被包含到定义函数的源文件中。

### 6.1.3 分离式编译

C++ 语言支持所谓的分离式编译。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。

#### 编译和链接多个源文件

## 6.2 参数传递

每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。形参的初始化机理和变量初始化一样。

形参的类型决定了形参和实参交互的方式。如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值 **拷贝** 后赋给形参。

当形参是引用类型时，我们说它对应的实参被 **引用传递** 或者函数被 **传引用调用** 。引用形参也是它绑定的对象的别名；也就是说， **引用形参是它对应的实参的别名** 。

当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。这样的 **实参被值传递** 或者 **函数被传值调用** 。

### 6.2.1 传值参数

当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。如果发生的是值传递，函数对形参做的所有操作都不会影响实参。

#### 指针形参

指针的行为和其他非引用类型一样。 **当执行指针拷贝操作时，拷贝的是指针的值** 。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接访问它所指向的对象。所以通过指针可以修改它所指向对象的值。 **指针的传递本质上还是值传递** 。

> 在 C++ 中，一般情况下建议使用引用类型的形参来代替指针传递。

### 6.2.2 传引用参数

对于引用的操作，实际上是作用在 **引用** 所引用的对象上。所以通过引用形参，允许函数改变一个或者多个实参的值。**引用形参绑定传入的实参，而非拷贝实参** 。

#### 使用引用避免拷贝

**拷贝大的类类型对象或者容器对象非常低效，甚至有的类型根本不支持拷贝操作** 。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类的对象。

> 如果函数无须改变引用形参的值，最好将其声明为常量引用。

#### 使用引用形参返回额外信息

一个函数只能有一个返回类型，一般情况下只能返回一个值。但是有时需要返回多个值，一种方法是定义一个新的数据类型，让它包含多个数据成员。还有一种就是传入引用，在函数中修改传入的实参。

### 6.2.3 `const` 形参和实参

这里我们主要强调的是顶层和底层 `const` 的区别。顶层 `const` 作用于当前对象本身。当使用实参初始化形参时会忽略掉顶层 `const` 。换句话说，形参的顶层 `const` 被忽略掉了。 **<u>当形参有顶层 `const` 时，传给它常量对象或者非常量对象都是可以的</u>** 。

C++ 中，顶层 `const` 会被编译器忽略掉，**所以仅仅在顶层 `const` 上存在差异的函数重载是错误的** 。

#### 指针或者引用形参与 `const`

形参的初始化方式和变量的初始化方式是一样的。我们可以使用非常量初始化一个底层 `const` 对象，然而反之不行。一个普通的引用必须使用同类型的对象初始化。

#### 尽量使用常量引用

把函数不会改变的形参定义成普通引用是一种比较常见的错误，这么做带给函数的调用者是一种误导，即函数可以修改它的实参的值。 **我们不能把 `const` 对象、字面值或者需要类型转换的对象传递给普通的引用形参** 。

### 6.2.4 数组形参

数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是： **不允许拷贝数组** ； **使用数组时会将其转换为指针** 。

**<u>因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换为指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针</u>** 。

尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：

```C++
// 尽管形式不同，但这三个print函数是等价的
// 每个函数都有一个const int*类型的形参
void print(const int*);
void print(const int[]); // 作用于一个数组
void print(const int[10]); // 这里的维度仅仅是一个期望，实际有多少不一定
```

如果我们传给 `print` 函数的是一个数组，则实参自动地转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。

> 和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界。

因为数组是以 **指针的形式** 传递给函数的，所以函数无法得知数组的确切尺寸，所以调用者也应当提供数组尽头信息。管理指针形参有三种常用的技术：

* **使用标记指定数组的长度** ：数组本身包含一个结束标记。
* **使用标准库规范** ：传递指向数组首元素和尾后元素的指针。
* **显式传递一个表示数组大小的形参** ：额外增加一个数组长度参数。

#### 数组形参和 `const`

当函数不需要对数组元素执行写操作的时候，数组形参应该是指向 `const` 的指针（ 底层 `const` ）。

#### 数组引用形参

C++ 允许将变量定义成为数组的引用。形参也可以是数组的引用。这时，引用形参绑定到对应的实参上，也就是绑定到数组上：

```C++
// 形参是数组的引用，维度是类型的一部分
void print(int (&arr)[10]) // 这里的括号不可少，而且引用中的维度是有意义的
{
    for (int elem : arr)
        std::cout << elem << " ";
    std::cout << std::endl;
}
```

#### 传递多维数组

所谓的多维数组其实是数组的数组。

当多维数组传递给函数时，真正传递的是 **指向数组首元素的指针** ，但是这里进行传递时 **一定要给出数组维度的第二维** ：数组第二维（以及后面的所有维度）的大小都是数组类型的一部分，**不能省略** 。

```C++
void print(int mat[][10], int row_size) { ... }
```

### 6.2.5 `main` ：处理命令行选项

当使用 `argv` 中的参数时，一定要记得可选的实参是从 `argv[1]` 开始；`argv[0]` 保存程序的名字，而非用户输入。

### 6.2.6 含有可变形参的函数

为了编写能处理不同数量实参的函数，C++11 标准提供了两种主要的方法：

* 如果所有实参类型类型相同，传递一个名为 `initializer_list` 的 **标准库类型** 。
* 如果实参的类型不同，编写 **可变参数模板** 。

C++ 还有一种特殊的形参类型（省略符），可以用它传递可变数量的实参。

#### `initializer_list` 形参

如果函数的 **实参数量未知但是全部实参的类型都相同** ，我们可以使用 **`initializer_list` 类型** 的形参。`initializer_list` 是一种标准库类型，用于表示某种特定类型的数组。 `initializer_list` 类型定义在同名头文件中。和 `vector` 不同的是， **`initializer_list` 对象中存储的永远是常量值，也就是说我们无法修改其中存储的数据** 。

**该容器可以使用迭代器进行操作** 。

#### 省略符形参

省略符形参是为了便于 C++ 程序访问某些特殊的 C 代码而设置的。省略符形参应该仅仅用于 C 和 C++ 通用的类型。

## 6.3 返回类型和 `return` 语句

`return` 语句 **终止当前正在执行的函数** 并 **将控制权返回到调用该函数的地方** 。注意这里首先终止当前函数，然后将控制权转移回调用当前函数的地方，有两步。

### 6.3.1 无返回值函数

**没有返回值的 `return` 语句只能用在返回类型是 `void` 的函数中** 。返回 `void` 的函数并要求非得是 `return` 语句，因为在这类函数的最后会隐式的执行 `return` 。

`void` 函数如果想在它的中间位置提前退出，可以使用 `return` 语句。

强行令 `void` 函数返回其他类型的表达式会产生编译错误。

### 6.3.2 有返回值函数

**只要函数的返回类型不是 `void` ，则该函数内的每条 `return` 语句必须返回一个值** 。 `return` 语句返回值的类型必须与函数的返回类型相同，或者能隐式的转换成函数的返回类型。

**在含有 `return` 语句的循环后面应该也有一条循环语句，如果没有的话该程序就是错误的** 。

#### 值是如何被返回的

**返回的值用于初始化调用点的接收变量** ，该接收变量是函数调用的结果。

#### 不要返回局部对象的引用或者指针

函数执行完毕之后，它所占用的储存空间也随之被释放掉。因此， **函数终止意味着局部变量的引用将指向不再有效的内存区域** 。

#### 返回类类型的函数和调用运算符

调用运算符的优先级与点运算符和箭头运算符相同，并且符合 **左结合律** 。

#### 引用返回左值

函数的返回类型决定函数调用是否是左值。 **调用一个返回引用的函数得到左值，其他返回类型为右值** 。

#### 列表初始化返回值

C++11 新标准规定，函数可以返回花括号包围的值的列表。这里注意，返回类型是 **可以被列表初始化的类型** 。

如果函数返回的是内置类型，则花括号包围的列表最多包含一个值。如果函数返回的是类类型，由类本身定义初始值如何使用。

#### 主函数 `main` 的返回值

允许 `main` 函数没有 `return` 语句直接结束。如果控制到达了 `main` 函数的结尾处而且没有 `return` 语句，编译器将隐式的插入一条返回 `0` 的 `return` 语句。

**`main` 函数的返回值可以是看作状态指示器**。返回 `0` 表示执行成功，返回其他值表示执行失败。

#### 递归

如果 **一个函数调用了它自身** ，不管这种调用是直接的还是间接的，都称该函数为 **递归函数** 。

在递归函数中，一定有某条路径是不包含递归调用的。无穷递归的情况被称为递归循环。

> `main` 函数不能调用它自己。

### 6.3.3 返回数组指针

函数可以返回数组的指针或者引用。

#### 声明一个返回数组指针的函数

要想在声明 `func` 时不使用类型别名，我们必须牢记被定义的名字后面数组的维度：

```C++
int arr[10]; // arr是一个含有10个整数的数组
int* arr[10]; // arr是一个含有10个指针的数组
int (*arr)[10] // arr是一个含有10个整数的数组的指针
```

当需要返回一个数组的时候，我们需要将函数声明成如下的形式：

```C++
// 返回一个长度为 10，类型为 int 的数组
int (*func(int i))[10];
```

可以按照以下的顺序来逐层理解该声明的含义：

* `func(int i)` 表示调用函数时需要一个 `int` 类型的形参。
* `(*func(int i))` 意味着我们可以对函数调用的结果执行解引用操作。
* `(*func(int i))[10]`表示解引用 `func` 的调用将得到一个大小是 `10` 的数组。
* `int (*func(int i))[10]` 表示数组中的元素是 `int` 类型。

#### 使用尾置返回类型

C++11 中有一种简明的声明方法，就是 **尾置返回类型** 。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效。

位置返回类型跟在形参列表后并以一个 `->` 符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个 `auto` ：

```C++
// func 接受一个 int 类型的实参，返回一个指针，该指针指向含有 10 个整数的数组
auto func(int i) -> int(*)[10];
```

#### 使用 `decltype`

如果我们知道函数返回的指针将指向哪个数组，就可以使用 `decltype` 关键字声明返回类型。

## 6.4 函数重载

如果同一个作用域内的几个函数名字相同但是 **形参列表** 不同，我们称之为 **重载函数** 。当调用函数时， **编译器会根据传递的实参来推断想要的时哪个函数** 。

> `main` 函数不能重载。

#### 定义重载函数

对于重载函数来说，它们应该在形参数量或者形参类型上有所不同。

不允许两个函数除了返回类型外其他所有的要素都相同。

#### 判断两个形参的类型是否相同

函数声明中，编译器会忽略掉顶层 `const` 。

#### 重载和 `const` 形参

顶层 `const` 不影响传入函数的对象。 **一个拥有顶层 `const` 的形参无法和另一个没有顶层 `const` 的形参区分开来** 。

如果形参是某种类型的指针或者引用，则 **通过区分其指向的是常量对象还是非常量对象可以实现函数重载** ，此时的 `const` 是底层的。

```C++
// 对于接受引用或者指针的函数来说，对象是常量还是非常量对应的形参不同
// 定义了 4 个独立的重载函数
Record lookup(Account& rhs); // 函数作用于 Account 的引用
Record lookup(const Account& rhs); // 新函数，作用于常量引用

Record lookup(Account* rhs); // 新函数，作用于指向 Account 的指针
Record lookup(const Account* rhs); // 新函数，作用于指向常量的指针，底层 const
```

编译器可以通过实参是否是常量来推断应该调用哪个函数。因为 `const` 不能转换成其他类型，所以我们只能把 `const` 对象或者指向 `const` 的指针传递给 `const` 形参。相反的，因为非常量可以转换成 `const` ，所以上面的 4 个函数都能作用于非常量对象或者指向非常量对象的指针。 **当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用 非常量 版本的函数** 。

#### 何时不应该重载函数

尽管函数重载能在一定程度上减轻我们为函数起名字、记名字的负担，但是最好只重载那些确实非常相似的操作。

#### `const_cast` 和重载

#### 调用重载的函数

函数匹配是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来， **函数匹配** 也叫做 **重载确定** 。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。

现在我们需要掌握的是，当调用重载函数时有三种可能的结果：

* 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。
* 找不到任何一个函数与调用的实参匹配，此时编译器发出 **无匹配** 的错误信息。
* 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为 **二义性调用** 。

### 6.4.1 重载与作用域

**如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名** 。

> 在 C++ 中，名字查找发生在类型检查之前。即：先找到名字，再检查类型。

## 6.5 特殊用途语言特性

**默认实参** 、 **内联函数** 和 **`constexpr` 函数** ，以及再程序调试过程中常用的一些功能。

### 6.5.1 默认实参

我们可以为一个或者多个形参都定义默认值，一旦某个形参被赋予了默认值，它右边的所有形参都必须默认值。

#### 使用默认实参调用函数

如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。

函数调用时实参按位置解析，默认实参负责填补函数调用缺少的尾部实参（右侧位置）。

当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序， **尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面** （左边的没有默认值可以，但是有默认值的右边不能没有默认值）。

#### 默认实参声明

**在给定的作用域中一个形参只能被赋予一次默认实参** 。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且 **该形参右侧的所有形参必须都有默认值** 。

通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。

#### 默认实参初始值

局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参。

用作默认实参的名字在函数生命所在的作用域内解析，而这些名字的求值过程发生在函数调用时。

### 6.5.2 内联函数和 `constexpr` 函数

调用函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。

#### 内联函数可避免函数调用的开销

将函数指定为内联函数，通常就是将它在每个调用点上 内联的 展开。从而消除函数运行时的开销。

在函数的返回类型前面加上关键字 `inline` ，这样就可以将它声明成内联函数了。

> 内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。

#### `constexpr` 函数

`constexpr` 函数是指 **能用于常量表达式的函数** 。定义 `constexpr` 函数的方法与其他函数类似，不过要遵循几项约定：

* 函数的返回值以及所有形参的类型都得是字面值类型。
* 函数体中必须有且仅有一条 `return` 语句。

```C++
constexpr int new_size() { return 42; }
constexpr int foo = new_size();
```

`constexpr` 函数被隐式的指定为内联函数。

#### 把内联函数和 `constexpr` 函数放在头文件内

内联函数和 `constexpr` 函数可以在程序中多次定义。

### 6.5.3 调试帮助

当应用程序编写完成准备发布时，要先屏蔽调试代码。这种方法用到两项预处理功能：`assert` 和 `NDEBUG` 。

#### `assert` 预处理宏

`assert` 是一种预处理宏。所谓预处理宏其实是一个 **预处理变量** ，它的行为有点类似内联函数。`assert` 宏使用一个表达式作为其条件： `assert(expr);` 。

首先对 `expr` 求值，如果表达式为假，`assert` 输出信息并终止程序。如果表达式为真，`assert` 什么也不做。

#### `NDEBUG` 预处理变量

`assert` 的行为依赖于一个名为 `NDEBUG` 的预处理变量的状态： **如果定义了 `NDEBUG` ，则 `assert` 什么也不做。默认状态下没有定义 `NDEBUG` ，此时 `assert` 将执行运行检查** 。

我们可以使用 `#define` 语句定义 `NDEBUG` ，从而关闭调试状态。

## 6.6 函数匹配

#### 确定候选函数和可行函数

函数匹配的第一步是 **选定本次调用对应的重载函数集** ，集合中的函数称为 **候选函数** 。候选函数具备两个特征：

* 与被调用的函数同名。
* 其声明在调用点可见。

第二步是 **考察本次调用提供的实参** ，然后 **从候选函数中选出能被这组实参调用的函数** ，这些新选出的函数称为 **可行函数** 。可行函数也有两个特征：

* **形参数量** 与本次调用提供的实参数量相等。
* 每个实参的 **类型** 与对应的形参类型相同，或者能转换成形参的类型。

> 如果没有找到可行函数，编译器将报告无匹配函数的错误。

#### 寻找最佳匹配（如果有的话）

函数匹配的第三步是 **从可行函数中选择与本次调用最匹配的函数** 。它的基本思想是： **实参类型与形参类型越接近，它们匹配的越好** 。

#### 含有多个形参的函数匹配

选择可行函数的方法和只有一个实参时一样，编译器选择那些形参数量满足要求且实参类型和形参类型能够匹配的函数。接下来，编译器依次检查每个实参以确定哪个函数是最佳匹配。如果有且仅有一个函数满足条件，则匹配成功：

* **<u>该函数每个实参的匹配都不劣于其他可行函数需要的匹配</u>** 。
* **<u>至少有一个实参的匹配优于其他可行函数提供的匹配</u>** 。

如果在检查了所有实参之后没有选中任何一个函数，则该调用是错误的。

> **<u>调用重载时应尽量避免强制类型转换</u>** 。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。

### 6.6.1 实参类型转换

1. **精确匹配** ，包括以下情况：
   * 实参类型和形参类型相同。
   * 实参从数组类型或函数类型转换成对应的指针类型。
   * 向实参添加顶层 `const` 或者从实参中删除顶层 `const` 。
2. **通过 `const` 转换实现的匹配** 。
3. **通过类型提升实现的匹配** 。
4. **通过算术类型转换或者指针转换实现的匹配** 。
5. **通过类类型转换实现的匹配** 。

#### 需要类型提升和算术类型转换的匹配

> 内置类型的提升和转换可能在函数匹配时产生意想不到的结果。

小整型一般都会提升到 `int` 类型或者更大的整数类型。

所有算术类型转换的级别都一样。

#### 参数匹配和 `const` 实参

如果重载函数的区别在于它们的引用类型的形参是否引用了 `const` ，或者指针类型的形参是否指向 `const` ，则当调用发生时编译器通过实参是否是常量来决定选择哪个函数。

## 6.7 函数指针

函数指针指向的是函数而非对象。函数指针指向某种特定的类型。**函数的类型由它的返回类型和形参共同决定** 。

要想声明一个可以指向函数的指针，只需要用指针替换函数名即可。

#### 使用函数指针

当我们把函数名作为一个值使用时，该函数自动的转换成指针，也就是说，取地址符是可选的。

我们可以直接使用指向函数的指针调用该函数，无须提前解引用指针。

#### 重载函数的指针

重载函数的指针需要在指针声明时确定形参列表，这样就可以进行精确重载了。

#### 函数指针形参

#### 返回指向函数的指针

```C++
int (*func(int))(int*, int);
```

`func` 函数的形参列表是 `int` ，返回类型是 `int(*)(int*, int*)` ： 一个指向函数的指针。

#### 将 `auto` 和 `decltype` 用于函数指针类型