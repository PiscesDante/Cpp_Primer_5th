# 第10章 泛型算法

**泛型** 是指这些算法可以用于不同的类型的元素以及多种容器类型。

## 10.1 概述

大多数算法都定义在头文件 `<algorithm>` 中。标准库头文件 `<numeric>` 中还定义了一组数值泛型算法。算法并不直接操作容器，而是 **遍历由两个迭代器指定的一个元素范围来进行操作** 。

```C++
int val = 42;
auto it = std::find(v.begin(), v.end(), val);
if (it == v.end()) {
    // not found;
} else {
    // found;
}
```

#### 算法如何工作

#### 迭代器令算法不依赖于容器，……

#### ……，但算法依赖于元素类型的操作

大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。

#### 关键概念：算法永远不会执行容器的操作

泛型算法本身不会执行容器的操作， **它们只运行于迭代器之上，执行迭代器的操作** 。这也就揭露了一个算法的本质：**<u>算法永远不会改变底层容器的大小</u>** 。算法可能改变容器中保存的元素，也可能移动容器内的元素，但永远不会直接添加或者删除元素。

**插入器** 是一种特殊的迭代器，插入器能在底层的容器上执行插入操作。

## 10.2 初识泛型算法

除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为 **<u>输入范围</u>** 。理解算法最基本的方法就是了解 **它们是否读取元素、改变元素或者是重排元素顺序** 。

### 10.2.1 只读算法

对于只读取而不改变元素的算法，通常最好使用 `cbegin` 和 `cend` 。但是，如果你计划使用算法返回的迭代器来改变元素的值，就需要使用普通类型的迭代器函数。

#### 操作两个序列的算法

那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。

### 10.2.2 写容器元素的算法

必须确保序列原大小至少不小于我们要求算法写入的元素数目。算法不会执行容器操作，因此它们自身不可能改变容器的大小。

#### 关键概念：迭代器参数

* 一些算法从两个序列中读取元素。构成这两个序列的元素可以来自不同类型的容器。
* 操作两个序列的算法之间的区别在于我们如何传递第二个序列。
* 用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个一样长。确保算法不会越界是程序员的责任。

#### 算法不检查写操作

向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳需要写入的元素。

#### 介绍 `back_inserter`

一种保证算法又足够元素控件来容纳输出数据的方法是使用 **插入迭代器** 。插入迭代器是一种向容器中添加元素的迭代器。普通的迭代器在插入元素的时候，插入的位置是迭代器指向的位置，而当我们通过插入迭代器赋值时，一个与赋值号右侧相等的元素会被 **添加** 到容器中。

`back_inserter` 是定义在头文件 `<iterator>` 中的一个 **函数** 。该函数接受一个容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用 `push_back` 将元素添加到容器中：

```C++
vector<int> v;
auto it = std::back_insert(v);
*it = 42; // 42 will be insert in the back;

vector<int> vec;
std::fill_n(std::back_inserter(vec), 10, 0);
// 添加 10 个 0 元素到容器 vec 中
```

#### 拷贝算法

算法接受三个迭代器，钱两个表示一个输入范围，第三个表示目的序列的起始位置。

```C++
int a1[] = { 1,2,3,4,5 };
int a2[sizeof(a1) / sizeof(int)];
auto ret = std::copy(std::begin(a1), std::end(a1), std::begin(a2));
```

### 10.2.3 重排容器元素的算法

`std::sort` 算法是通过元素类型的 `<` 运算符来实现排序的，也就是说，只有一个类型定义了 `<` 逻辑关系，才能使用 `std::sort` 算法。

#### 消除重复单词

一旦容器中的内容完成排序，我们就可以使用另一个称为 `std::unique` 的标准库算法来重排容器，使得不重复的元素出现在容器的开始部分。由于算法不执行容器的操作，所以需要使用容器本身的 `erase` 函数来完成真正的删除操作。

```C++
void elimDups(vector<string>& words)
{
    // 按字典序排序 words ，以便查找重复的单词
    sort(words.begin(), words.end());
    // unique 重排输入范围，使得每一个单词只出现一次
    // 排列在范围的前部，返回指向不重复区域之后一个位置的迭代器
    auto end_unique = unique(words.begin(), words.end());
    // 使用向量操作 erase 删除重复的单词
    words.erase(end_unique, words.end());
}
```

`sort` 算法接受两个迭代器，表示要排序的元素范围。

#### 使用 `unique`

`unique` 函数并不删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分。 `unique` 返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但是不知道值是什么。

> 标准库算法对迭代器而不是容器操作。因此，算法不能直接添加或者删除元素。

#### 使用容器操作删除元素

## 10.3 定制操作

如果序列未定义 `<` 运算符的元素类型，或者需要其他的方式排列容器中的元素。那么就需要重载 `sort` 的默认行为。

### 10.3.1 向算法传递函数

`sort` 第二个版本除了范围迭代器之外，还接受第三个参数，这个参数是一个 **谓词** 。

#### 谓词

**谓词** 是一个可以调用的表达式，其返回结果是一个能作为条件的值。标准库算法所使用的谓词分为两类： **一元谓词** 和 **二元谓词** 。

```C++
// 比较字符串长短
bool is_shorter(const string& s1, const string& s2)
{
    return s1.size() < s2.size();
}

// 按长度由短到长来排列容器
sort(words.begin(), words.end(), is_shorter);
```

#### 排序算法

为了保持相同长度的单词按照字典序进行排列，可以使用 `stable_sort` 算法。这种稳定排序算法维持相等元素的原有顺序。

### 10.3.2 `lambda` 表达式

