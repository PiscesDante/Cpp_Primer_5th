# 15.2.1 节练习

## 练习 15.1

> 什么是虚成员？

解答：

虚成员是基类中声明且定义的，并且基类希望自己的派生类能够实现自己版本的成员函数。虚成员使用关键字 `virtual` 进行修饰。

## 练习 15.2

> `protected` 访问说明符与 `private` 有何区别？

解答：

声明为 `protected` 的成员可以被派生类直接访问，而声明为 `private` 的成员不能被任何其他类直接访问。派生类也不行。

## 练习 15.3

> 定义你自己的 `Quote` 类和 `print_total` 函数。

解答：

```C++
class Quote {
public:
    Quote() = default;
    Quote(const std::string& bn, double up) :
        book_no(bn), unit_price(up) {  }
    std::string isbn() const { return book_no; }
    virtual double net_price(std::size_t amount) const { return unit_price * amount; }
    virtual ~Quote();
protected:
    double unit_price { 0.0 };
private:
    std::string book_no { "NULL" };
};

double print_total(std::ostream& os, const Quote& item, std::size_t amount)
{
    double ret = item.net_price(amount);
    os << "ISBN: " << item.isbn() << " | ";
    os << "#Sold: " << amount << " | ";
    os << "#Income: " << ret * amount << std::endl;
    return ret;
}
```

# 15.2.2 节练习

## 练习 15.4

> 下面哪条声明语句是不正确的？请解释原因。

```C++
class Base { ... };
(a) class Derived : public Derived { ... };
(b) class Derived : private Base { ... };
(c) class Derived : public  Base;
```

解答：

```C++
class Base { ... };
(a) class Derived : public Derived { ... }; // 错误：一个类不可继承其自身
(b) class Derived : private Base { ... };   // 正确：继承 Base 类
(c) class Derived : public  Base;           // 错误：声明语句中不应包含类派生列表
```

## 练习 15.5

> 定义你自己的 `Bulk_quote` 类。

解答：

```C++
class Bulk_quote : public Quote {
public:
    Bulk_quote() = default;
    Bulk_quote(const std::string bn, double up, std::size_t mq, double dc) :
        Quote(bn, up), min_quantity(mq), discount(dc) {  }
    double net_price(std::size_t amount) const override;
    ...
private:
    std::size_t min_quantity;
    double discount;
};

double Bulk_quote::net_price(std::size_t amount) const
{
    if (amount >= min_quantity) {
        return amount * unit_price * (1 - discount);
    } else {
        return amount * unit_price;
    }
}
```

## 练习 15.6

> 将 `Quote` 和 `Bulk_quote` 的对象传给 15.2.1 节（第 529 页）练习中的 `print_total` 函数，检查该函数是否正确。

解答：

```C++
#include <iostream>
#include <string>

class Quote {
public:
    Quote() = default;
    Quote(const std::string& bn, double up) :
        book_no(bn), unit_price(up) {  }
    std::string isbn() const { return book_no; }
    virtual double net_price(std::size_t amount) const { return amount * unit_price; }
    virtual ~Quote() {  }
protected:
    double unit_price;
private:
    std::string book_no;
};

class Bulk_quote : public Quote {
public:
    Bulk_quote() = default;
    Bulk_quote(const std::string bn, double up, std::size_t mq, double dc) :
        Quote(bn, up), min_quantity(mq), discount(dc) {  }
    double net_price(std::size_t amount) const override;
private:
    std::size_t min_quantity;
    double discount;
};

double Bulk_quote::net_price(std::size_t amount) const
{
    if (amount >= min_quantity) {
        return amount * unit_price * (1 - discount);
    } else {
        return amount * unit_price;
    }
}

double print_total(std::ostream& os, const Quote& item, std::size_t amount)
{
    double ret = item.net_price(amount);
    os << "ISBN: " << item.isbn() << " | ";
    os << "#Sold: " << amount << " | ";
    os << "#Income: " << ret * amount << std::endl;
    return ret;
}

int main(int argc, char* argv[])
{
    Quote book1("Book one", 12.99);
    Bulk_quote book2("Book Two", 29.99, 100, 0.7);
    print_total(std::cout, book1, 100);
    print_total(std::cout, book2, 50);
    print_total(std::cout, book2, 200);
    // ISBN: Book one | #Sold: 100 | #Income: 129900
    // ISBN: Book Two | #Sold: 50 | #Income: 74975
    // ISBN: Book Two | #Sold: 200 | #Income: 359880
    return 0;
}
```

## 练习 15.7

> 定义一个类使其实现一种数量受限的折扣策略，具体策略是：当购买书籍的数量不超过一个给定的限量时享受折扣，如果购买量一旦超过了限量，则超出的部分将以原价销售。

解答：

```C++
class New_bulk_quote : public Quote {
public:
    New_bulk_quote() = default;
    New_bulk_quote(const std::string bn, double up, std::size_t mq, double dc) :
        Quote(bn, up), max_quantity(mq), discount(dc) {  }
    double net_price(std::size_t amount) const override;
private:
    std::size_t max_quantity;
    double discount;
};

double New_bulk_quote::net_price(std::size_t amount) const
{
    if (amount <= max_quantity) {
        return amount * unit_price * (1 - discount);
    } else {
        return (amount - max_quantity) * unit_price + 
                max_quantity * unit_price * (1 - discount);
    }
}
```

# 15.2.3 节练习

## 练习 15.8

> 给出静态类型和动态类型的定义。

解答：

* 静态类型：在编译期就已经明确的对象的类型。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型。
* 动态类型：在编译期无法确定，直到运行期才能确定的类型。动态类型是变量或者表达式表示的内存中的对象的类型。

## 练习 15.9

> 在什么情况下表达式的静态类型可能与动态类型不同？请给出三个静态类型与动态类型不同的例子。

解答：

当静态类型是类类型的引用或者指针类型时，静态类型可能与动态类型有所不同。

```C++
class Quote { ... };
class Bulk_quote : public Quote { ... };

Bulk_quote bulk;
Quote& quote_ref = bulk; // 1
Quote* quote_ptr = &bulk; // 2
Quote* quote_ptr2 = new Bulk_quote(); // 3
```

## 练习 15.10

> 回忆我们在 8.1 节（第 279 页）进行的讨论，解释第 284 页中将 `ifstream` 传递给 `Sales_data` 的 `read` 函数的程序是如何工作的。

解答：

之所以 `read` 函数可以接受一个 `ifstream` 的对象是因为 `ifstream` 类派生自类 `istream` 类。 `istream` 类型的引用可以绑定在 `ifstream` 对象上。

# 15.3 节练习

## 练习 15.11

> 为你的 `Quote` 类体系添加一个名为 `debug` 的虚函数，令其分别显示每个类的数据成员。

解答：

```C++
class Quote {
public:
    virtual void debug() const;
};

void Quote::debug() const
{
    ...
}

class Bulk_quote : public Quote {
public:
    virtual void debug() const override;
};

void Bulk_quote::debug() const
{
    ...
}
```

## 练习 15.12

> 有必要将一个成员函数同时声明成 `override` 和 `final` 吗？为什么？

解答：

可以， `override` 表示对继承来的虚函数进行覆盖；而 `final` 表示继承自本类的派生类无法继续重写该虚函数。

## 练习 15.13

> 给定下面的类，解释每个 `print` 函数的机理：

```C++
class base {
public:
    std::string name { return basename; }
    virtual void print(std::ostream& os) { os << basename; }
private:
    std::string basename;
};

class derived : public base {
public:
    void print(std::ostream& os) { print(os); os << " " << i; }
private:
    int i;
};
```

> 在上述代码中存在问题吗？如果有，你该如何修改它？

解答：

有问题，在 `derived::print(std::ostream& os)` 函数中，调用语句 `print(os)` 会直接调用 `derived::print(std::ostream& os)` ，而这会造成无限递归。修改方法：

```C++
class base {
public:
    std::string name { return basename; }
    // 向传入的输出流中写入成员 basename
    virtual void print(std::ostream& os) { os << basename; }
private:
    std::string basename;
};

class derived : public base {
public:
    // 覆盖继承来的虚函数 void print(std::ostream& os)
    void print(std::ostream& os) {
        // 先强制调用基类的 print 函数输出当前对象基类部分
        base::print(os);
        // 输出当前对象的派生类部分
        os << " " << i;
    }
private:
    int i;
};
```

## 练习 15.14

> 给定上一题中的类以及下面这些对象，说明在运行时调用哪个函数：

```C++
base bobj;       base* bp1 = &bobj;    base& br1 = bobj;
derived dobj;    base* bp2 = &dobj;    base& br2 = dobj;
```

解答：

```C++
(a) bobj.print(); // base::print
(b) dobj.print(); // derived::print
(c) bp1->name(); // base::name
(d) bp2->name(); // derived::name
(e) br1.print(); // base::print
(f) br2.print(); // derived::print
```