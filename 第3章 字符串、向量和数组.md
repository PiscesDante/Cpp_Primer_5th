# 第3章 字符串、向量和数组

`string` 和 `vector` 是两种最重要的 **标准库类型** ，前者支持 **可变长字符串** ，后者则表示 **可变长的集合** 。还有一种标准库类型就是 `iterator` ，它是 `string` 和 `vector` 的配套类型，常被用于访问 `string` 中的字符或者 `vector` 中的元素。

## 3.1 命名空间的 `using` 声明

我们使用 **作用域操作符（ `::` ）** 来指定所使用的命名空间，其含义是：**<u>编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字</u>** 。

避免显式的使用以上方法，可以使用 `using` 声明。有了 `using` 声明 就无需专门的前缀也能使用特定作用域的名字了：

```C++
using namespace::name;
```

一旦声明了上述语句，就可以直接访问命名空间中的名字：

```C++
#include <iostream>

using std::cin;

int main(int argc, char* argv[])
{
    int i;
    cin >> i; // 正确：使用了 using std::cin
    cout << i; // 错误：没有使用 using std::cout
    return 0;
}
```

#### 每个名字都需要独立的 `using` 声明

```C++
#include <iostream>

// 通过下列 using
// 使用标准库中的名字
using std::cin;
using std::cout;
using std::endl;

int main(int argc, char* argv[])
{
    cout << "Enter two numbers: " << endl;
    int v1, v2;
    cin >> v1 >> v2;
    cout << "The sum of " << v1 << " and " << v2;
    cout << " is: " << v1 + v2 << endl; 
    return 0;
}
```

用到的每个名字都必须有自己的声明语句，而且每句话都得以分号结束。

#### 头文件不应包含 `using` 声明

如果一个头文件里有某个 `using` 声明，那么每个使用了这个头文件的文件就都会有这个声明。这样可能会产生意想不到的冲突。

#### 一点注意事项

## 3.2 标准库类型 `string`

标准库类型 `string` 表示 **可变长的字符序列** 。使用 `string` 类型必须首先包含 `string` 头文件。 `string` 定义在命名空间 `std` 中。

标准库类型对于一般应用场合来说应该有足够的效率。

### 3.2.1 定义和初始化 `string` 对象

```C++
string s1; // 默认初始化，s1 是一个空字符串
string s2 = s1; // s2 是 s1 的副本
string s3 = "Hola"; // s3 是该字符串字面值的副本
string s4(10, 'c'); // s4: cccccccccc
// 这种初始化的方式比较少用，但是很重要
// std::string s(number_of_char, char_itself);
string s5(s4);
string s6("HOLA");
```

**如果提供的是一个数字 `k` 和一个字符 `ch`，那么 `string` 对象中的内容是 `ch` 的连续 `k` 次重复序列** 。

#### 直接初始化和拷贝初始化

如果使用 **等号（ `=` ）** 初始化一个变量，实际上执行的是 **拷贝初始化** ：编译器把等号右侧的初始值 **拷贝** 到新创建的对象中去。相反的，如果不使用等号，则执行的是 **直接初始化** 。

```C++
string s5 = "HOLA"; // 拷贝初始化
string s6(s5); // 直接初始化
string s7(7, 'c'); // 直接初始化：ccccccc
```

### 3.2.2 `string` 对象上的操作

#### 读写 `string` 对象

```C++
#include <iostream>
#include <string>

int main(int argc, char* argv[])
{
    std::string s; // 定义 s
    std::cin >> s; // 从 std::cin 向 s 写入
    std::cout << s << std::endl;
    // 向 std::cout 写入 s（输出）
    return 0;
}
```

在执行读取操作时， **<u>`string` 对象会自动忽略开头的空白（空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止</u>** 。

和内置类型的输入输出操作一样，`string` 对象的此类操作也是返回 **运算符左侧的运算对象** 作为其结果。因此，可以将多个输出连写在一起：

```C++
std::string s1, s2;
std::cin >> s1 >> s2; // 第一个输出写入 s1， 第二个输入写入 s2
std::cout << s1 << s2 << std::endl; // 输出
```

#### 读取未知数量的 `string` 对象

```C++
#include <iostream>
#include <string>

int main(int argc, char* argv[])
{
    std::string word;
    // 反复读取，直至到达文件末尾
    // 如果流有效，也就是说没有遇到文件结束标记或者非法输入
    while (std::cin >> word) {
        // 逐个输出单词，每个单词后面紧跟一个换行
        std::cout << word << std::endl;
    }
    return 0;
}
```

#### 使用 `getline` 读取一整行

如果希望保留一行中的空白字符，这时应该使用 `getline` 函数代替原来的 `>>` 运算符。 `getline` 函数的参数是 **一个输入流** 和 **一个 `string` 对象** ：函数从给定的输入流中读入内容，直到遇到换行符为止（这里换行符也被读进来了），然后将所读的内容存入到传进来的 `string` 对象中去（这里不存换行符）。

`getline` 函数也会返回 其用的流参数。因此，`getline` 的返回结果也能作为控制流的判断条件。

```C++
#include <iostream>
#include <string>

int main(int argc, char* argv[])
{
    std::string line;
    // 每次读入一整行，直到文件末尾（EOF）
    while (getline(std::cin, line)) {
        std::cout << line << std::endl;
    }
    return 0;
}
```

**触发 `getline` 函数返回的换行符实际上是被丢掉了** 。

#### `string` 的 `empty` 和 `size` 操作

```C++
#include <iostream>
#include <string>

int main(int argc, char* argv[])
{
    std::string line;
    // 每次读入一整行，直到文件末尾（EOF）
    while (getline(std::cin, line)) {
        if (!line.empty() && line.size() > 10) {
            std::cout << line << std::endl;
        }
    }
    return 0;
}
```

#### `string::size_type` 类型

`string::size` 函数返回的实际上是一个 `string::size_type` 类型的值，而并非想象中的 `int` 或者 `size_t` 。但可以确信的是是一个 **无符号整数** 。所以如果一条表达式中已经有了 `size` 函数就不要再使用 `int` 了。

#### 比较 `string` 对象

如果两个 `string` 对象在某些对应的位置上不一致，则结果为 **两个对象中第一对相异字符比较的结果** 。如果两个字符串在相同长度上的字符一致，那么就是 **较短的字符串较小** 。

#### 为 `string` 对象赋值

#### 两个 `string` 对象相加

当把 `string` 对象和字符字面值以及字符串字面值混在一条语句中使用时，必须 **确保 ·每个加法运算符的两侧· 的运算对象至少有一个是 `string`** 。

```C++
string s4 = s1 + ", "; // 正确
string s5 = "hello" + ","; // 错误：两个对象都不是 string
string s6 = s1 + ", " + "world"; // 错误
string s7 = "hello" + "," + s2; // 错误：不能把字面值直接相加
```

### 3.2.3 处理 `string` 对象中的字符

如果需要改变某个字符的特性，那么就需要包含进来 `cctype.h` ，该头文件中定义了一组标准库函数处理这部分工作。

#### 使用 C++ 版本的 C 标准库头文件

* C 版本： `#include <stdio.h>`
* C++ 版本： `#include <cstdio>`

#### 处理每个字符？使用基于范围的 `for` 语句

范围 `for` 语句 **遍历给定序列中的每个元素并且可以对序列中的每个值执行某种操作** 的语法形式：

```C++
for (declararion : expression){
    statements...
}
```

比如说：

```C++
int main(int argc, char* argv[])
{
    std::string s("HELLO WORLD");
    for (char ch : s) {
        std::cout << ch << std::endl;
    }
    return 0;
}
```

#### 适用范围 `for` 语句改变字符串中的字符

如果想要改变 `string` 对象中字符的值，就必须将循环变量定义成 **引用类型** 。

#### 只处理一部分字符？

下标运算符（ `[]` ）接收的参数是 `string::size_type` 类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的 **引用** 。

**在访问指定字符之前，首先检查字符串是否为空** 。其实不管什么时候只要对字符串对象使用了下标，都要确认在那个位置上确实有值。 **如果字符串为空，那么任何索引操作都是未定义的** 。

#### 使用下标进行迭代

```C++
for (
    decltype(s.size()) index = 0;
    index != s.size() && isspace(s[index]);
    ++index;
) {
    s[index] = toupper(s[index]);
}
```

#### 使用下标执行随机访问

**无论何时用到字符串的下标，都应该注意检查其合法性** 。

## 3.3 标准库类型 `vector`

C++ 语言既有 **类模板**，也有 **函数模板** ，其中 `vector` 是一个类模板。模板本身不是类或者函数，但是可以将模板看作 **为编译器生成类或者函数编写的一份说明** 。编译器根据模板创建类或者函数的过程称为 **实例化** 。

以 `vector` 为例：

```C++
// std::vector<typename> identifier;
std::vector<int> ivec; // ivec 保存 int 类型对象
std::vector<Sales_item> Sales_vec;
std::vector<std::vector<std::string>> file;
```

`vector` 是 **模板** 而非 **类型** 。

### 3.3.1 定义和初始化 `vector` 对象

#### 初始化 `vector` 对象的方法

```C++
std::vector<T> vec;
std::vector<T> v2(v1); // 拷贝构造
std::vector<T> v2 = v1; // 同上
std::vector<T> v3(n, val);
std::vector<T> v4(n); // n 个 默认初始化的值
std::vector<T> v5 { a, b, c }; // 列表初始化
std::vector<T> v6 = { a, b, c, d };
```

事实上，最常见的方式就是先定义一个空的 `vector` ，然后在运行时向其中添加元素。

```C++
std::vector<int> ivec; // 初始状态为空
// 在此处给 ivec 添加一些值
std::vector<int> ivec2(ivec); // 拷贝构造
std::vector<int> ivec3 = ivec; // 拷贝构造函数
std::vector<std::string> svec(ivec);
// 错误：拷贝构造过程中两个 vector 的类型必须相同
```

#### 列表初始化 `vector` 对象

```C++
std::vector<std::string> svec { "a", "an" };
```

注意： **列表初始化不能使用圆括号** 。

#### 创建指定数量的元素

```C++
std::vector<int> ivec(10, 0);
// ivec 中含有 10 个 0
sd::vector<std::string> svec(5, "NULL");
// svec 中含有 5 个 "NULL"
```

#### 值初始化

```C++
std::vector<int> v1(10);
// 对容器内的 10 个 int 执行值初始化（默认初始化）
```

#### 列表初始值还是元素数量

初始化的真实含义依赖于传递初始值时用的是 **花括号** 还是 **圆括号** 。当使用花括号时，代表列表初始化；当使用圆括号时，可以说提供的值是用来构造 `vector` 对象的，代表元素数量。

然而，如果初始化时使用了花括号的形式，但是提供的值又不能用来列表初始化，编译器就会使用其中的值来调用构造函数：

```C++
std::vector<std::string> svec { 10 };
// 这里会被编译器解释为
// svec 中有 10 个 默认初始化的 std::string 对象
// 虽然使用了花括号，但是本质上还是使用了构造函数
```

**确认无法执行列表初始化之后，编译器就会尝试用默认值初始化 `vector` 对象** 。

### 3.3.2 向 `vector` 对象中添加元素

一般的情况就是：**先创建一个空的 `vector` ，然后在运行时再利用 `vector` 的成员函数 `push_back` 向其中添加元素** 。 `push_back` 负责把一个值当成 `vector` 对象的尾元素 压入 容器的 尾端。

#### 向 `vector` 对象添加元素蕴含的编程假定

**必须要确保所写的循环准确无误，特别是在循环有可能改变 `vector` 对象的容量的时候** ：如果循环体内部有向 `vector` 容器内添加元素的动作，那么禁止使用范围 `for` 循环。

### 3.3.3 其他 `vector` 操作

#### 计算 `vector` 内对象的索引

#### 不能使用下标形式添加元素

**`vector` 对象（以及 `string` 对象）的下标运算符可用于访问已经存在的元素，而不能用于添加元素** 。也就是说，**只能对确知已经存在的元素执行下标操作** 。确保下标合法的一种有效手段就是 **尽可能的使用范围 `for` 循环语句** 。

## 3.4 迭代器介绍

更通用的机制实现访问字符串或者容器的元素，就是 **迭代器** 。类似于 **指针类型** ，其指向的对象是容器中的元素或者 `string` 对象中的字符。使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另一个元素，迭代器有有效和无效之分，这一点和指针差不多。有效迭代器或者要么指向某个元素，要么指向容器尾元素的下一个位置。

### 3.4.1 使用迭代器

使用迭代器要通过对象的成员函数 `begin` 和 `end` 。其中 `begin` 成员函数负责返回指向第一个成员的迭代器。

```C++
// 由编译器决定 b 和 e 的类型
// b 表示 v 的第一个元素，e 表示 v 最后一个元素的下一个位置
auto b = v.begin();
auto e = v.end();
// b 和 e 拥有相同的类型
```

`end` 成员返回的迭代器指向的其实是一个根本不存在的 **断后元素** 。这个迭代器并没有什么含义，只是一个代表容器末尾的标记而已。所以也被称为 **尾后迭代器** 。

如果容器为空，那么 `begin` 和 `end` 返回的都是 **尾后迭代器** 。

#### 迭代器运算符

使用 `==` 或者 `!=` 来判断迭代器是否相等。试图解引用一个非法迭代器和尾后迭代器都是未定义的行为。

#### 将迭代器从一个元素移动到另外一个元素

迭代器使用递增和递减运算符来移动到下一个或者上一个元素（逻辑上对递增和递减运算符进行重载）。

#### 泛型编程

使用 `!=` 或者 `==` 的原因主要是：因为这种风格在标准库提供的所有容器上都有效。毕竟所有的标准库容器的迭代器都定义了 `!=` 和 `==` ，但其中大多数却没有定义 `<` 运算符。

#### 迭代器类型

一般来说我们也不知道迭代器的精确类型。实际上，那些拥有迭代器的标准库类型使用 `iterator` 和 `const_iterator` 来表示迭代器的类型：

```C++
std::vector<int>::iterator it; // it 能读写 std::vector<int> 的元素
std::string::iterator it2; // it2 能读写 std::string 对象中的元素
std::vector<int>::const_iterator it3; // it3 只能读取 std::vector<int> 中的元素
```

如果使用迭代器的容器是一个 **常量对象** ，那么就只能使用 `const_iterator` 。

#### `begin` 和 `end` 运算符

`begin` 和 `end` 返回的具体类型由对象是否为常量决定，如果对象是常量， `begin` 返回的是 `const_iterator` ；如果对象不是常量，返回 `iterator` 。

为了便于专门得到 `const_iterator` 类型的返回值，C++11 引入了两个新的成员函数：`cbegin` 和 `cend` 。

#### 结合解引用和成员访问操作

解引用迭代器可以获得迭代器所指的对象。并且进一步的，可以使用这个结果访问其成员：

```C++
// 这里的圆括号必不可少
(*iter).member_method();
```

为了简化上述表达式，C++ 语言定义了 **箭头运算符（ `->` ）** ：

```C++
(*iter).member_method();
iter->member_method();
// 以上两个语句表达的是一个意思
```

#### 某些对 `vector` 对象的操作会使迭代器失效

任何改变容器中元素个数的操作都会使原本的容器迭代器失效。谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属容器添加元素。

### 3.4.2 迭代器运算

迭代器不仅可以前后移动，还可以计算两个迭代器的差来计算出它们的距离。

#### 迭代器算术运算

可以另迭代器和一个整数值相加减，返回值就是向前或者向后移动了若干个位置的迭代器。

```C++
// 计算得到最接近 vi 中间元素的迭代器
auto mid = vi.begin() + (vi.size() / 2);
```

如果 `vi` 有 `20` 个元素，那么 `vi.size() / 2 == 10` ，就相当于 `mid = vi.begin() + 10` ，下标从 `0` 开始，那么就相当于 `vi[10]` ，也就是 **从首元素开始向前移动 `10` 个位置的那个元素** 。

只要两个迭代器指向的是同一个容器中的元素，就能将其相减，得到的结果就是 **两个迭代器的距离** 。也就是右侧的迭代器向后移动多少距离就能等于左侧的迭代器，这个类型是名为 `difference_type` 的带符号整数类型。

#### 使用迭代器运算

二分查找的例子。

## 3.5 数组

数组是存放类型相同对象的容器，这些被存放的对象本身没有名字，需要通过其所在的位置进行访问。数组的大小确定不变，不能随意向数组中增加元素。数组的大小是固定的。

如果不清楚元素的个数，还是推荐使用 `std::vector` 。

### 3.5.1 定义和初始化内置数组

数组是一种 **复合类型** 。数组的维度必须大于零。编译的时候维度必须是可知的，也就是说，维度必须是一个 **常量表达式** ：

```C++
unsigned cnt = 42; // 不是常量表达式
constexpr unsigned sz = 42; // 常量表达式
int arr[10]; // 含有 10 个 int 对象的数组 arr
int* parr[sz]; // 含有 42 个 int* 对象的数组 parr
std::string bad[cnt]; // 错误：cnt 不是常量表达式
std::string strs[get_size()]; // 当 get_size 是 constexpr 时正确，否则错误
```

#### 显式初始化数组元素

可以对数组的元素进行列表初始化，此时允许忽略数组的维度。但如果指明了维度，那么初始化列表的长度则不应超过指定的维度。如果列表长度小于指定的维度，剩下的元素将被默认初始化。

```C++
const unsigned sz = 3;
int arr[sz] = { 1, 2, 3 }; // [1,2,3]
int arr[] = { 1, 2, 3 }; // [1,2,3]
int arr[5] = { 1, 2, 3 }; // [1,2,3,0,0]
std::string arr[3] = { "A", "B" }; // ["A", "B", ""]
int arr[2] = { 1, 2, 3 }; // 错误：初始值过多
```

#### 字符数字的特殊性

可以使用 **字符串字面值** 来初始化 **字符数组** 。这种方式有个问题，就是字符串字面值的结尾还有一个 **空字符 `\0`** 。这个 **空字符** 也会被拷贝到字符数组里面去：

```C++
char a1[] = { 'C', '+', '+' }; // 列表初始化，没有空字符
char a2[] = { 'C', '+', '+', '\0' }; // 列表初始化，显式的含有空字符
char a3[] = "C++"; // 自动添加表示字符串结束的空字符
const char a4[] = "Daniel"; // 错误：没有空间存放空字符！
```

#### 不允许拷贝和赋值

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：

```C++
int a1[] = { 1, 2, 3 };
int a2[] = a1; // 错误：不允许使用另一个数组进行初始化
a2 = a1; // 错误：禁止直接赋值
```

#### 理解复杂的数组声明

```C++
int* ptrs[10]; // 存放 10 个 int指针 的数组 ptrs
// int& refs[10]; // 错误：不存在引用的数组
int (*arr_ptr)[10]; // 一个可以指向维度为 10 的数组的 数组指针
int (&arr_ref)[10]; // 一个可以引用维度为 10 的数组的 数组引用
```

要想理解数组生命的含义，最好的办法就是从数组的名字开始 **由内向外** 的顺序阅读。

### 3.5.2 访问数组元素

数组元素也能使用 **范围 `for` 语句** 或者 **下标运算符** 来访问。数组下标的类型为 `size_t` ，定义在 `<cstddef>` 头文件中。

#### 检查下标的值

### 3.5.3 指针和数组

**使用数组的时候编译器一般会把它转换成指针** 。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此，对数组的元素使用取地址符就能得到指向该元素的指针：

```C++
std::string nums[] { "ONE", "TWO", "THREE" };
std::string* p = &nums[0]; // p 指向 "ONE"
```

数组的另外一个特性： **<u>很多使用数组名字的场合，编译器都会自动的将其替换成一个 指向数组首元素的指针</u>** 。大多数表达式中， **使用数组类型的对象** 其实是 **使用一个指向该数组首元素的指针** 。所以，对数组的操作其实是对于指针的操作，也就是说，<u>当使用一个数组进行 `auto` 的推断数组类型时，得到的是一个 **数组元素类型的指针**</u> ：

```C++
int arr[3] { 1, 2, 3 };
// 表面上：
auto arr2(arr);
// 实际上：
auto arr2(&arr[0]);
```

然而必须指出的是：**<u>当使用 `decltype` 关键字进行转换时，得到的类型却是 由 `n` 个源元素构成的数组</u>** ：

```C++
int arr[3] { 1, 2, 3 };
// arr3 是一个含有 3 个整数的数组：
decltype(arr) arr3;
arr3[0] = 42; // 合法
```

#### 指针也是迭代器

容器的迭代器支持的运算，数组的指针也全部都支持。通过 **数组的名字** 或者 **数组首元素的地址** 都能得到指向首元素的指针。相同的，我们也可以用同样的手段来获取 **尾后指针** ：

```C++
#include <cstddef> // size_t
const size_t sz = 5;
int arr[sz] { 1, 2, 3, 4, 5 };
int* begin = arr; // 首元素指针
int* end = &arr[sz]; // 尾后指针
```

#### 标准库函数 `begin` 和 `end`

以上的方法虽然能正确获得相应的指针，但是这种方法非常容易出错。为了更加安全的执行上述操作，C++11 新标准引入了 `begin` 和 `end` 函数：

```C++
#include <iterator>
// std::begin() 和 std::end()
const size_t sz = 5;
int arr[sz] { 1,2,3,4,5 };
int* head_ptr = std::begin(arr); // 指向首元素
int* after_tail_ptr = std::end(arr); // 指向尾元素的下一个位置
```

**尾后指针和迭代器不能执行解引用和递增操作** 。

#### 指针运算

运算包括：解引用、递增递减、比较、与整数相加减、两个指针相减，用在指针和用在迭代器上的意义完全一样。

给一个指针加上一个整数值，结果仍然是指针。新指针指向的元素与原来的指针相比前进了该整数值个位置。指针相减时必须指向同一个数组中的元素。指针相减的类型是一种名为 `ptrdeff_t` 的标准库类型，定义在 `<cstddef>` 头文件中。是一种带符号类型。

如果两个指针分别指向不相关的对象，则不能进行比较，因为两个无关的地址的比较是毫无意义的。

#### 解引用和指针运算的交互

#### 下标和指针

很多情况下使用数组的名字其实使用的是一个指向数组首元素的指针。编译器会自动的进行转换：

```C++
int arr[] { 0,2,4,6,8 };
// 当我们表面上使用：
int i = arr[2];
// 实际上执行：
int* p = arr;
int i = *(p + 2);
```

所以，只要指针指向的是数组中的元素，都可以执行下标运算：

```C++
int* p = &arr[2];
int j = p[-1]; // arr[2 - 1]
int k = p[3]; // arr[2 + 3]
```

标准库类型限定使用的下标必须是 **无符号类型** ，而内置数组没有这个要求。

### 3.5.4 C 风格字符串

尽管 C++ 支持 C 风格字符串，但是在 C++ 程序中最好还是不要使用它们。不仅非常简陋，而且会引发安全问题。

C 风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按照这个书写习惯的字符串存放在字符数组中并以 **空字符（ `\0` ）** 结束。

#### C 标准库 String 函数

#### 比较字符串

#### 目标字符串的大小由调用者指定

### 3.5.5 与旧代码的接口

#### 混用 `string` 对象和 C 风格字符串

任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：

* 允许使用以空字符结束的字符数组来初始化 `string` 对象或为 `string` 对象赋值。
* 在 `string` 对象的加法运算中允许使用以空字符结尾的字符数组作为其中一个运算对象。

如果要使用 `string` 对象来初始化一个指向字符的指针，可以使用 `string` 类的 `c_str` 函数：

```C++
char* sp = s; // 错误：不能用 string 对象初始化一个指针
const char* sp = s.c_str(); // 正确
```

#### 使用数组初始化 `vector` 对象

只需要传递给 `vector` 对象要拷贝区间的 **首元素地址** 和 **尾后地址** 就行了：

```C++
int arr[] { 1,2,3,4,5,6,7,8 };
std::vector<int> vec (std::begin(arr), std::end(arr)); // 完全拷贝
std::vector<int> vec (arr, arr + 4); // 拷贝 0 ~ 3 号元素
```

#### 尽量使用标准库类型而非数组

现代 C++ 程序应当尽量使用 `vector` 和迭代器，避免使用内置数组和指针；应该尽量使用 `string` ，避免使用 C 风格的字符串。

## 3.6 多维数组

通常所说的多维数组其实是数组的数组。

```C++
int arr[3][4]; // 长度为 3 的数组，每个元素是含有 4 个整数的数组
int arr[10][10][10];
// arr 包含 10 个元素
// arr[i] 包含 10 个元素
// arr[i][j] 包含 10 个元素
```

理解多维数组要分层去理解，具体到每一层都有自己的结构。对于二维数组来说，通常将第一个维度称作行，第二个维度称作列。

#### 多维数组的初始化

允许使用花括号括起来的一组值初始化多维数组，这点和普通的数组一样：

```C++
int mat[3][4] {
    { 1, 2, 3, 4 }, // mat[0]
    { 2, 3, 4, 5 }, // mat[1]
    { 3, 4, 5, 6 }  // mat[2]
};

int arr[2][3] { 1,2,3,4,5,6 }; // 这样的初始化方式也是可以的
```

如果给出的元素不够初始化所有的位置，那么剩余的元素执行默认初始化。

#### 多维数组的下标引用

可以使用下标运算符来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。程序中经常会用到两层嵌套的 `for` 循环来处理多维数组。

#### 使用范围 `for` 语句来处理多维数组

```C++
int arr[3][4] { 0 };
size_t cnt = 0;
for (auto& row : arr) {
    for (auto& cell : row) {
        col = cnt++;
    }
}
// 0, 1, 2, 3
// 4, 5, 6, 7
// 8, 9, 10, 11
```

尽管也许不会修改第一维的值，但是还是应当将其声明为引用类型，因为如果直接声明为值类型的话，C++ 有可能将第一维存储的数组处理成指针类型，这样就不能使用范围循环进行处理了。

**谨记：要使用范围 `for` 循环语句处理多维数组，除了最内层的循环之外，其他所有循环的控制变量都应当是引用类型** 。

#### 指针和多维数组

当程序使用多维数组的名字时，也会将其自动的转换为首元素指针。定义指向多维数组的指针时，千万不要忘记这个多维数组本质上是一个 **数组的数组** 。

```C++
int mat[3][4];
int (*p_row)[4] = &mat[0]; // 指向长度为 4 的数组
p = &mat[3]
```

上述声明中，**圆括号** 必不可少：

```C++
int* arr_of_pointer[4]; // 含有 4 个指针对象的数组
int (*pointer_of_arr)[4] = nullptr; // 指向含有 4 个整型变量的数组的指针
```

#### 类型别名简化多维数组的指针

