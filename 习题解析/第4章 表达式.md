# 4.1.2 节练习

## 练习 4.1

> 表达式 `5 + 10 * 20 / 2` 的求值结果等于多少？

解答：

```C++
5 + 10 * 20 / 2 ->
5 + 200 / 2 ->
5 + 100 ->
105
```

## 练习 4.2

> 根据 4.12 节中的表，在下述表达式的合理位置天加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。

解答：

```C++
(a) *vec.begin(); -> *(vec.begin());
(b) *vec.begin() + 1; -> (*(vec.begin()) + 1);
```

# 4.1.3 节练习

## 练习 4.3

> C++ 语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行的权衡，你认为这可以接受吗？请说出你的理由。

解答：

不能接受，毕竟这个特性在后来的语言中都被抛弃了。如果这是一个非常好的特性，Java 和 C# 的设计者不可能将其抛弃。

# 4.2 节练习

## 练习 4.4

> 在下面的表达式中添加括号，说明其求值的过程以及最终结果。编写程序编译该（不加括号的）表达式并输出结果验证之前的推断。

解答：

```C++
12 / 3 * 4 + 5 * 15 + 24 % 4 / 2 ->
16 + 75 + 0 ->
91
```

```C++
#include <iostream>

int main(int argc, char* argv[])
{
    std::cout << 12 / 3 * 4 + 5 * 15 + 24 % 4 / 2 << std::endl;
    // 91
    return 0;
}
```

## 练习 4.5

> 写出下列表达式的求值结果。

解答：

```C++
(a) -30 * 3 + 21 / 5 -> -90 + 4 -> -86
(b) -30 + 3 * 21 / 5 -> -30 + 12 -> -18
(c) 30 / 3 * 21 % 5 -> 210 % 5 -> 0
(d) -30 / 3 * 21 % 4 -> -210 % 4 -> -2
```

## 练习 4.6

> 写出一条表达式用于确定一个整数是奇数还是偶数。

解答：

```C++
x % 2 ? "Odd" : "Even"
```

## 练习 4.7

> 溢出是何含义？写出三条将导致溢出的表达式。

解答：

当计算的结果超出该类型所能表示范围时，就会产生溢出。

```C++
short x = 5000 * 6000 * 7000;
unsigned j = -1;
short k = -999999999999999999999999999;
```

# 4.3 节练习

## 练习 4.8

> 说明在逻辑与、逻辑或以及相等性运算符中运算对象的求值顺序。

解答：

* 逻辑与和逻辑或都有 **短路求值** 的特点：从左向右开始求值，左边的运算对象可以确定整个表达式的值时，就不会对右侧的运算对象求值。
* 相等性运算符没有特定的求值顺序，需要看具体的编译器实现。

## 练习 4.9

> 解释在下面的 `if` 语句中条件部分的判断过程。

解答：

```C++
const char* cp = "Hello World";
if (cp && *cp)
// 如果 [cp是一个有效的指针] 然后且 [cp指向的对象不是一个空串]
```

## 练习 4.10

> 为 `while` 循环条件写一个条件，使其从标准输入中读取整数，遇到 42 时停止。

解答：

```C++
int x;
while (std::cin >> x && x != 42) { ... }
```

## 练习 4.11

> 书写一条表达式用于测试 4 个值 `a, b, c, d` 的关系，确保 `a` 大于 `b`，`b` 大于 `c`，`c` 大于 `d` 。

解答：

```C++
if (a > b && b > c && c > d) { ... }
```

## 练习 4.12

> 假设 `i`、`j` 和 `k` 是三个整数，说明表达式 `i != j < k` 的含义。

解答：

* 首先计算 `i != j` 的值，该值是个布尔类型，返回 `0` 或者 `1` 。
* 然后计算 `0 < k` 或者 `1 < k` ，返回值也是个布尔类型。

结论：如果 `1 < k` 那么条件恒成立；如果 `0 < k <= 1` 条件有可能成立（ 取决于 `i != j` ）；如果 `0 <= k` 条件恒不成立。

# 4.4 节练习

## 练习 4.13

> 在下述语句中，当赋值完成后 `i` 和 `d` 的值分别是多少？

解答：

```C++
int i;
double d;
(a) d = i = 3.5; // d == 3; i == 3;
(b) i = d = 3.5; // i == 3; d == 3.5;
```

## 练习 4.14

> 执行下述 `if` 语句后将发生什么情况？

解答：

```C++
if (42 = i) { ... } // 非法：42 不能作为左值
if (i = 42) { ... } // 合法：但是条件永远成立
// 因为赋值语句 i = 42 返回的值是 42，永远非 0
```

## 练习 4.15

> 下面的赋值是非法的，为什么？应该如何修改？

解答：

```C++
double dval; int ival; int* pi;
dval = ival = pi = 0;
// 当 0 赋给 pi 这个指针的时候，已经转换成了指针的类型
// 再用一个指针的值去给 int 类型的变量赋值本身就是非法的
// 应当修改为：
pi = nullptr;
dval = 0;
ival = 0;
```

## 练习 4.16

> 尽管下面的语句合法，但它们实际执行的行为可能和预期并不一样，为什么？应该如何修改？

解答：

```C++
(a) if (p = get_ptr() != 0)
// 这个语句本意是将 get_ptr 的返回值赋给 p 然后判断是否为一个空指针
// 但是赋值运算符的优先级要低于不等运算符，故实际上是将 get_ptr() != 0 的结果赋给 p
// 应当修改为：
if ((p = get_ptr()) != 0)

(b) if (i = 1024)
// 条件的本意是判断 i 是否和 1024 相等
// 但实际上是将 1024 赋值给 i 然后返回 1024 这个非零数
// 结果是条件永久成立
// 应当修改为：
if (i == 1024)
```

# 4.5 节练习

## 练习 4.17

> 说明前置递增运算符和后置递增运算符的区别。

解答：

* 前置版本：首先改变运算对象，然后将改变后的对象作为结果返回。前置版本将 **对象本身作为左值返回** 。
* 后置版本：先返回运算对象改变前的副本，再改变运算对象本身。后置版本 **返回运算对象原始值的副本，这个副本本质上是一个右值** 。

## 练习 4.18

> 如果第 132 页那个输出 `vector` 对象元素的 `while` 循环使用前置递增运算符，将得到什么结果？

解答：

因为递增运算符的优先级高于解引用运算符，那么操作就会变为先递增迭代器本身，然后再解引用递增后的迭代器，那么结果就是 **第一个元素被跳过** 。

## 练习 4.19

> 假设 `ptr` 的类型是指向 `int` 的指针、`vec` 的类型是 `vector<int>` 、`ival` 的类型是 `int`，说明下面的表达式是何含义？如果有表达式不正确，为什么？应该如何修改？

解答：

```C++
(a) ptr != 0 && *ptr++ // 如果 ptr 不是空指针 且 ptr 指向的值非 0
(b) ival++ && ival // 如果 ival 非 0 且 ival + 1 非 0
(c) vec[ival++] <= vec[ival] // 不正确：不等号两边运算对象的求值顺序是任意的，应当修改为：
vec[ival] <= vec[ival + 1]
```

# 4.6 节练习

## 练习 4.20

> 假设 `iter` 的类型是 `std::vector<std::string>::iterator` ，请说明下面的表达式是否合法。如果合法，表达式的含义是什么？如果不合法，错在何处？

解答：

```C++
(a) *iter++; // 合法：递增运算符返回 iter 的副本，然后递增 iter 本身，* 作用于返回的副本
(b) (*iter)++; // 非法：递增运算符无法作用于 std::string 对象
(c) *iter.empty(); // 非法：点运算符的优先级高于解引用运算符，迭代器本身没有 empty 成员
(d) iter->empty(); // 合法：访问 iter 指向的对象的 empty 成员
(e) ++*iter; // 合法：先递增迭代器本身，然后访问迭代器指向的对象
(f) iter++->empty(); // 合法：先访问返回的副本指向的对象的 empty 成员，然后递增迭代器
```

# 4.7 节练习

## 练习 4.21

> 编写一段程序，使用条件运算符从 `std::vector<int>` 中找到哪些元素的值时奇数，然后将这些奇数值翻倍。

解答：

```C++
#include <iostream>
#include <vector>

int main(int argc, char* argv[])
{
    std::vector<int> vec { 1,2,3,4,5,6,7,8,9,10 };
    for (int& elem : vec) (elem % 2) ? elem *= 2 : elem;
    return 0;
}
```

## 练习 4.22

> 本节的示例程序将成绩划分为 `high pass` 、`pass` 和 `fail` 三种，扩展该程序使其进一步将 `60` 分到 `75` 分之间的成绩设定为 `low pass` 。要求程序包含两个版本：一个版本只能使用条件运算符；另外一个版本使用 `1` 个或者多个 `if` 语句。哪个版本的程序更容易理解呢？为什么？

解答：

```C++
// 条件运算符版本
std::string final_grade = (score < 75) ?
        ((score < 60) ? "fail" : "low pass") : ((score < 90) ? "pass" : "high pass");
```

```C++
// if - else 版本
std::string final_grade;
if (score < 60) final_grade = "fail";
else if (score < 75) final_grade = "low pass";
else if (score < 90) final_grade = "pass";
else final_grade = "high pass";
```

很明显是 `if - else` 版本的程序容易理解。

## 练习 4.23

> 因为运算符优先级的问题，下面的表达式无法通过编译。根据 4.12 节中的表（第 147 页）指出它的问题在哪里？应该如何修改？

解答：

```C++
std::string s = "word";
std::string p1 = s + s[s.size() - 1] == 's' ? "" : "s";
// 该条语句等价于：
std::string p1 = s + s[s.size() - 1] == 's';
p1 ? "" : "s";
// s 不能和一个 bool 类型的变量相加
// 应当修改为：
std::string p1 = s + ((s[s.size() - 1] == 's') ? "" : "s");
```

## 练习 4.24

> 本节的示例程序将成绩划分成 `high pass` 、`pass` 、`fail` 三种，它的依据是条件运算符满足右结合律。假如条件运算符满足的是左结合律，求值过程时怎样的？

解答：

如果是左结合的，那么表达式：

```C++
final_grade = score > 90 ? "high pass" : (score < 60) ? "fail" : "pass";
```

就会等价于：

```C++
final_grade = (score > 90 ? "high pass" : (score < 60)) ? "fail" : "pass";
```

也就是说，如果在 `90` 以上，那么求值为 `high pass`，然后因为这个字符串非空，于是整体表达式返回 `fail` 。如果在 90 以下，那么如果在 60 和 90 之间，返回 `pass`，否则返回 `fail` 。这显然有非常大的问题。

# 4.8 节练习

## 练习 4.25

> 如果一台机器上 `int` 占 `32` 位、`char` 占 `8` 位，用的是 `Latin-1` 字符集，其中字符 `q` 的二进制形式是 `01110001` ，那么表达式 `~q << 6` 的值是什么？

解答：

```C++
// 首先对 q 去反：
~01110001 -> 10001110
// 然后左移 6 位
10001110 -> 10000000
// 2 的 8 次方 = 十进制表示下的：256
```

## 练习 4.26

> 在本节关于测验成绩的例子中，如果使用 `unsigned int` 作为 `quiz1` 的类型会发生什么情况？

解答：

使用 `long` 类型的目的就是要保证在任何机器上都至少占 `32` 位，如果使用 `int` 类型，那么在有些机器上很可能只占 `16` 位。这样的话就无法表示全部的学生，而且位移步数大于类型长度会导致为定义的行为。

## 练习 4.27

> 下列表达式的结果是什么？

解答：

```C++
unsigned long ul1 = 3;
unsigned long ul2 = 7;
(a) ul1 & ul2
00000011 -> 3
00000111 -> 7
00000011 -> 3 #

(b) ul1 | ul2
00000011 -> 3
00000111 -> 7
00000111 -> 7 #

(c) ul1 && ul2 -> true;

(d) ul1 && ul2 -> true;
```

# 4.9 节练习

## 练习 4.28

> 编写一段程序，输出每一种内置类型所占空间的大小。

解答：

```C++
#include <iostream>

int main(int argc, char* argv[])
{
    std::cout << "char: " << sizeof (char) * 8 << " bits" << std::endl;
    std::cout << "short: " << sizeof (short) * 8 << " bits" << std::endl;
    std::cout << "int: " << sizeof (int) * 8 << " bits" << std::endl;
    std::cout << "long: " << sizeof (long) * 8 << " bits" << std::endl;
    std::cout << "float: " << sizeof (float) * 8 << " bits" << std::endl;
    std::cout << "double: " << sizeof (double) * 8 << " bits" << std::endl;
    return 0;
}

/**
 * char: 8 bits
 * short: 16 bits
 * int: 32 bits
 * long: 32 bits
 * float: 32 bits
 * double: 64 bits
*/
```

## 练习 4.29

> 推断下面代码的输出结果并说明理由。实际运行这段程序，结果和你想象的一样吗？如果不一样，为什么？

解答：

```C++
#include <iostream>

int main(int argc, char* argv[])
{
    int x[10]; // 数组
    int* p = x; // 指针 - 64 位：指向 x[0]
    std::cout << sizeof (x) / sizeof (*x) << std::endl; // 10
    // 10 * int / int -> 10
    std::cout << sizeof (p) / sizeof (*p) << std::endl; // 2
    // p: 64 bits / *p: 32 bits -> 2
    return 0;
}
```

结果同预想的一样。

## 练习 4.30

> 根据 4.12 节中的表（第 147 页），在下述表达式的适当位置加上括号，使得加上括号之后表达式的含义与原来的含义相同。

解答：

```C++
(a) sizeof x + y; -> sizeof (x + y);
(b) sizeof p->mem[i]; -> sizeof (p->mem[i]);
(c) sizeof a < b; -> sizeof (a) < b;
(d) sizeof f(); -> sizeof (f());
```

# 4.10 节练习

## 练习 4.31

> 本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。想要使用后置版本的递增递减运算符需要做出哪些改动？使用后置版本重写本节的程序。

解答：

使用前置版本的原因是相同的效果下，后置版本需要制作一份运算对象递增或者递减之前的副本，这就会占用一部分的内存。所以使用前置版本可以减少空间上的开销。

如果想要使用后置版本不需要做任何的改动，因为无论是前置还是后置，程序需要的仅仅是递增这个 **副作用** 。

```C++
std::vector<int>::size_type cnt = ivec.size();
for (
    std::vector<int> size_type ix = 0;
    ix != ivec.size();
    ix++, cnt--
) ivec[ix] = cnt;
```

## 练习 4.32

> 解释下面这个循环的含义。

解答：

```C++
constexpr int size = 5;
int ia[size] { 1,2,3,4,5 }; // 元素数量为 5 的整型数组
for (
    int* ptr = ia, int ix = 0; // ptr -> ia[0]; ix = 0
    ix != size && ptr != ia + size; // ix != 5 && ptr !-> ia[5]
    ++ix, ++ptr // ix = ix + 1; ptr -> ptr.next;
) { ... }
```

## 练习 4.33

> 根据 4.12 节中的表（第 147 页）说明下面这条表达式的含义。

解答：

```C++
someValue ? ++x, ++y : --x, --y;
// 这个语句本质上是：
(someValue ? ++x, ++y : --x) , --y;
```

如果 `someValue` 为真，那么 `++y` 然后 `--y`，得到初始 `y` 值；如果 `someValue` 为假，那么只得到 `--y` 。

# 4.11.1 节练习

## 练习 4.34

> 根据本节给出的变量的定义，说明在下面的表达式中将发生什么样的类型转换。需要注意每种运算符遵循的是左结合律还是右结合律。

解答：

```C++
(a) if (fval) { ... }; // fval -> bool
(b) dval = fval + ival; // ival -> float; fval + (float)ival -> double
(c) dval + ival * cval; // cval -> int; ival * (int)cval -> double
```

## 练习 4.35

> 假设有如下的定义：

```C++
char cval; int ival; unsigned int ui;
float fval; double dval;
```

> 请回答下面的表达式中发生了隐式转换吗？如果有，指出来。

解答：

```C++
(a) cval = 'a' + 3; // a -> int; ('a' + 3) -> char
(b) fval = ui - ival * 1.0; // ival -> double, ui -> double; rhs -> float;
(c) dval = ui * fval; // ui -> float; rhs -> double
(d) cval = ival + fval + dval; // ival -> float; (ival + fval) -> double; rhs -> char
```

# 4.11.3 节练习

## 练习 4.36

> 假设 `i` 是 `int` 类型，`d` 是 `double` 类型，书写表达式 `i *= d` 使其执行整数类型的乘法而非浮点数类型的乘法。

解答：

```C++
i *= static_cast<int>(d);
```

## 练习 4.37

> 用命名的强制类型转换改写下列旧式的转换语句。

解答：

```C++
int i; double d; const std::string* ps; char* pc; void* pv;

(a) pv = (void*)ps; // pv = static_cast<void*>(ps);
(b) i = int(*pc); // i = static_cast<int>(*pc);
(c) pv = &d; // pv = static_cast<void*>(&d);
(d) pc = (char*)pv; // pc = static_cast<char*>(pv);
```

## 练习 4.38

> 说明下面这条表达式的含义。

```C++
double slope = static_cast<double>(j / i);
```

解答：

将 `j / i` 的运算结果强制转换成 `double` 类型之后用来初始化 `double` 类型的变量 `slope` 。