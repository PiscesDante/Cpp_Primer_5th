# 第15章 面向对象程序设计

面向对象程序设计基于三个概念： **数据抽象** 、**继承** 和 **动态绑定** 。

继承和动态绑定对程序的编写有两方面的影响：

1. 我们可以更容易的定义与其他类「大同小异」的新类。
2. 使用这些大同小异的类编写程序的时候，可以在一定程度上忽略掉它们的区别。

## 15.1 OOP：概述

**面向对象程序设计** 的核心思想是：

* **数据抽象** ：将类的接口和实现分离；
* **继承** ：可以定义相似的类型并对其相似关系建模；
* **动态绑定** ：可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象；

#### 继承

通过 **继承** 联系在一起的类构成一种层次关系。通常在这个关系的根部有一个 **基类** ，而其他类则直接或间接的从基类继承而来，这些继承得到的类称为 **派生类** 。 **基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员** 。

建模：定义一个名为 `Quote` 的类作为基类。 `Quote` 的对象表示按原价销售的书籍。 `Quote` 派生出一个名为 `Bulk_quote` 的类，它表示可以打折销售的书籍。

这些类将包含下面的两个成员函数：

* `isbn()` ：返回书籍的 `isbn` 编号。仅定义在 `Quote` 类中。
* `net_price(std::size_t)` ：返回书籍的实际销售价格，前提是用户购买这个书籍达到一定的数量，这个操作显然是类型相关的。

在 C++ 语言中，基类将 **类型相关的函数** 与 **派生类不做改变直接继承的函数** 区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就需要将这样的函数声明为 **「虚函数」** ：

```C++
class Quote {
public:
    std::string isbn() const;
    // Quote 希望继承它的派生类自己完成 net_price 的定义
    virtual double net_price(std::size_t amount) const;
};
```

派生类必须通过使用 **「类派生列表」** 来明确指出它是从哪些基类派生而来的。类派生列表的形式是：**首先一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有「访问说明符」** ：

```C++
class Bulk_quote : public Quote { // Bulk_quote 继承了 Quote
public:
    double net_price(std::size_t amount) const override;
};
```

因为 `Bulk_quote` 在它的派生列表中使用了 `public` 关键字，因此我们完全可以把 `Bulk_quote` 的对象当成 `Quote` 的对象来使用。

派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 `virtual` 关键字，但并不是非要这样做。**C++ 新标准允许派生类显式的注明它将使用哪个成员函数改写基类的虚函数** ，具体措施就是在形参列表之后加上关键字 `override` 。

#### 动态绑定

使用该特性，我们能用同一段代码分别处理 `Quote` 对象和 `Bulk_quote` 对象 。

```C++
// 计算并且打印销售给定数量的某种书籍所得的费用
double print_total(std::ostream& os, const Quote& item, std::size_t amount)
{
    // 根据传入的 item 形参的对象类型调用 Quote::net_price
    // 或者 Bulk_quote::net_price
    double ret = item.net_price(amount);
    os << "ISBN: " << item.isbn() << " | "; // 调用 Quote::isbn()
    os << "# Sold: " << amount << " | ";
    os << "Total Due: " << ret << std::endl;
    return ret;
}
```

我们既能使用基类 `Quote` 的对象来调用这个函数，也能使用派生类 `Bulk_quote` 的对象来调用这个函数；因为该函数是使用引用类型来调用 `net_price` 成员函数的，也就是说： **<u>实际传入 `print_total` 函数的对象类型将决定到底执行基类还是派生类的 `net_price` 成员函数</u>** ：

```C++
// quote 的类型是 Quote，bulk 的类型是 Bulk_quote
print_total(std::cout, quote, 20); // Quote::net_price
print_total(std::cout, bulk, 20); // Bulk_quote::net_price
```

因为上述过程中，函数的运行版本由实参的类型决定，即在运行时选择函数的版本，所以 **<u>动态绑定</u>** 又被称为 **<u>运行时绑定</u>** 。

> 在 C++ 中，使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。

## 15.2 定义基类和派生类

### 15.2.1 定义基类

```C++
class Quote {
public:
    Quote() = default;
    Quote(const std::string& isbn, double sales_price) :
        book_no(isbn), unit_price(sales_price) {  }
    std::string isbn() const { return book_no; }
    // 返回给定数量的书籍的销售总额
    // 派生类负责改写并使用不同的折扣计算算法
    virtual double net_price(std::size_t amount) const { return amount * unit_price; }
    virtual ~Quote(); // 对析构函数进行动态绑定
private:
    std::string book_no; // 书籍 ISBN 编号
protected:
    double unit_price = 0.00; // 代表普通状态下不打折的价格
};
```

> 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

#### 成员函数与继承

派生类需要对虚操作提供自己的新定义以 **<u>覆盖（ `override` ）</u>** 从基类继承来的旧定义。

基类必须将它的两种成员函数区分开来：

* 基类希望其派生类进行覆盖的函数（ 基类使用 **虚函数** ）；
* 基类希望派生类直接继承而不改变的函数。

当我们使用指针或者引用调用虚函数时，该调用也将被动态绑定。根据指针或者引用类型的不同，该调用可能执行基类或者派生类的版本。

基类通过在其成员函数的声明语句之前加上关键字 `virtual` 使得该函数执行动态绑定。虚函数的核心特征：

* 任何 **<u>构造函数之外</u>** 的 **<u>非静态函数</u>** 都可以是虚函数。
* **<u>关键字 `virtual` 只能出现在类内部的声明语句之前</u>** 而不能用于类外部的函数定义。
* **如果基类将一个函数声明为虚函数，那么该函数在派生类中隐式的也是虚函数** 。

成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。

#### 访问控制与继承

派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承来的成员。 **基类的私有成员不能被派生类直接访问** 。

### 15.2.2 定义派生类

派生类必须通过使用 **<u>类派生列表</u>** 明确指出它是从哪个（些）基类继承而来的。**<u>首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个： `public` ， `protected` 或者 `private`</u>** 。

派生类必须将其继承来的成员函数中 **需要覆盖的那些重新声明** 。因此，我们的 `Bulk_quote` 类必须包含一个 `net_price` 成员：

```C++
class Bulk_quote : public Quote {
public:
    Bulk_quote() = default;
    Bulk_quote(const std::string&, std::size_t, double);
    double net_price(std::size_t) const override;
private:
    std::size_t min_qty = 0; // 适用折扣的最低购买量
    double discount = 0.0; // 小数表示的折扣
};
```

派生类列表中的「访问说明符」的作用是：**<u>控制派生类从基类继承而来的成员是否对派生类的用户可见</u>** 。如果是公有继承，则基类的公有成员也是派生类接口的组成部分。此外， **<u>可以将公有派生类型的对象绑定到基类的引用或者指针上</u>** 。

大多数类都只派生自一个类，这种形式的继承被称为「单继承」。

#### 派生类中的虚函数

**如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他普通成员，派生类会直接继承其在基类中的版本** 。

#### 派生类对象及派生类向基类的类型转换

派生类对象包含多个组成部分：

* **<u>含有派生类自己定义的（非静态）成员的「子对象」</u>** 。
* **<u>与该派生类继承的「基类对应的子对象」，如果有基类，那么这样的「子对象」也有多个</u>** 。

**<u>也就是说，派生类对象其实是个缝合怪，它不是一个普通的对象，而是由几个子对象组成的一个复合对象</u>** 。 C++ 对象没有明确规定派生类的对象在内存中如何分布。

因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类的对象使用，而且我们也能将基类的指针或者引用绑定到派生类对象的基类子对象上：

```C++
Quote item; // 基类对象
Bulk_quote bulk_item; // 派生类对象
Quote* p = &item; // p 指向基类对象
p = &bulk_item; // p 指向派生类对象中的基类子对象
Quote& r = bulk_item; // r 绑定到 bulk_item 对象中的 Quote 子对象上
```

这种转换通常称为 **派生类到基类的类型转换** 。编译器会隐式的执行派生类到基类的转换。这个特点意味着，我们可以将派生类的对象用在基类引用或者指针的地方。

> **在派生类对象中含有一个基类的子对象，这一事实是继承的关键所在** 。

#### 派生类构造函数

派生类构造函数无法直接初始化继承而来的成员。 **<u>派生类必须使用基类的构造函数来初始化它的基类子对象</u>** 。

> **每个类控制它自己的成员初始化过程** 。

派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。

```C++
class Quote;
class Bulk_quote : public Quote {
public:
    Bulk_quote(
        const std::string& bn, double up,
        std::size_t qty, double disc
        // 必须使用 Quote 来构造从基类继承而来的成员
        // 而不是直接像自有成员那样直接进行构造
    ) : Quote(bn, up), min_qty(qty), discount(disc) {  }
    ...
};
```

可以看出，要构造 `Bulk_quote` 对象，首先要将前两个参数传递给 `Quote` 构造函数，在 `Quote` 构造函数 **<u>函数体</u>** 结束之后，我们构建的 `Bulk_quote` 基类部分也就构造完成了。接下来初始化列表会初始化由派生类直接定义的 `min_qty` 成员和 `discount` 成员，最后运行 `Bulk_quote` 构造函数的（空的）函数体。

> 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。

#### 派生类使用基类的成员

派生类可以访问基类的公有成员和受保护成员：

```C++
// 如果达到了购买书籍的某个最低限量值，就可以享受折扣
double Bulk_quote::net_price(std::size_t amount) const
{
    if (amout >= min_quantity) {
        return amount * price * (1 - discount);
    } else {
        return amount * price;
    }
}
```

**<u>派生类的作用域嵌套在基类的作用域之内</u>** 。因此，对于派生类的一个成员来说，它使用派生类成员的方式和使用基类成员的方式没有不同。

#### 关键概念：遵循基类的接口

每个类负责定义各自的接口。**<u>要想与类的对象交互，必须使用该类的接口，即使这个对象是派生类的基类部分也是如此</u>** 。因此，派生类对象不能直接初始化基类的成员。尽管在派生类构造函数体内给其继承来的公有或者受保护的基类成员赋值（强烈建议不这样做）。 **<u>派生类应当遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类继承而来的成员</u>** 。

#### 继承与静态成员

如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出多少个派生类，对于每个静态成员来说都只存在 **<u>唯一的实例</u>** 。

静态成员遵循通用的访问规则，如果基类的中的成员是 `private` 的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它，也能通过派生类使用它。

```C++
class Base {
public:
    static void statmem();
};

class Derived : public Base {
    void func(const Derived& de);
};

void Derived::func(const Derived& de) {
    Base::statmem(); // 正确：Base 定义了 statmem
    Derived::statmem(); // 正确：Derived 可以访问继承来的 statmem
    // 正确：派生类的对象能访问基类的静态成员
    de.statmem(); // 通过 Derived 对象进行访问
    statmem();    // 通过 this 对象进行访问
}
```

#### 派生类的声明

派生类的声明中包含类名，**<u>但是不包含类派生列表</u>** ：

```C++
class Bulk_quote : public Quote; // 错误：派生列表不能出现在声明中
class Bulk_quote; // 正确：类声明的正确方式！
```

一条声明语句的目的是 **<u>令程序知晓某个名字的存在以及该名字表示一个什么样的实体，例如一个类、一个变量或者一个函数</u>** 。类派生列表现在不需要出现在这里（类派生列表属于定义的范畴）。

#### 被用作基类的类

**<u>如果一个类要被用作基类，则该类必须已经定义</u>** ！

* 派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类需要知道这些成员是什么。
* 一个类不能派生其本身。

一个类可以是基类的同时也是派生类：

```C++
class Base { ... };
class D1 : public Base { ... };
class D2 : D1 { ... };
```

`Base` 是 `D1` 的 **直接基类** ，同时是 `D2` 的 **间接基类** 。直接基类出现在类派生列表中，而间接基类由派生类通过其直接基类派生而来。 **<u>每个类都会继承直接基类的所有成员</u>** 。并且以此进行递归。因此，**最终的派生类将包含它的直接基类的子对象，以及每个间接基类的子对象** 。

#### 防止继承的发生

如果不希望一个类被继承，那么就在类名之后跟一个关键字： `final` ：

```C++
class NoDerived final { ... }; // NoDerived 不能作为基类
class Base { ... };
// Last 是 final 的，不能继承 Last
class Last final : Base { ... }; // Last 不能作为基类
class Bad : NoDerived { ... }; // 错误：NoDerived 是 final 的
class Bad2 : Last { ... };     // 错误：Last 是 final 的
```

### 15.2.3 类型转换与继承

**<u>理解基类和派生类之间的类型转换是理解 C++ 语言面向对象编程的关键</u>** 。

**<u>我们可以将基类的指针或者引用绑定到派生类的对象上</u>** 。而这一特性具有一个非常重要的含义： **<u>当使用基类的引用或者指针时，实际上我们并不清楚该引用或者指针绑定的真实类型，绑定的对象可能是个基类的对象，也可能是派生类对象</u>** 。

> 和内置指针一样，智能指针类也支持派生类向基类的内行转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。

#### 静态类型与动态类型

当使用存在继承关系的类型时，必须将一个变量或者其他表达式的 **静态类型** 与 该表达式表示对象的 **动态类型** 区分开来。

* **<u>表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型</u>** 。
* **<u>动态类型则是变量或者表达式表示的内存中的对象的类型</u>** 。动态类型直到运行时才可知。

比方说：

```C++
double ret = item.net_price(amount);
```

这里 `item` 的静态类型是 `Quote&` ，它的动态类型则依赖于 `item` 绑定的实参（可能会绑定 `Quote` 对象，也可能会绑定 `Bulk_quote` 对象），这个动态类型直到运行时调用该函数时才会知道。举例来说，如果我们将一个 `Bulk_quote` 对象传递给函数 `print_total( ... const Quote& item, ...)` ，那么 `item` 的静态类型是 `Quote` ，而动态类型是 `Bulk_quote` 。

**<u>如果表达式既不是引用，也不是指针，则它的动态类型永远与静态类型一致</u>** 。

> **<u>基类的指针或者引用的静态类型可能与其动态类型不一致</u>** 。

#### 不存在从基类向派生类的隐式类型转换……

之所以存在派生类向基类的类型转换是因为： **<u>每个派生类对象都包含一个基类部分，而基类的引用或者指针可以绑定到该基类部分上</u>** 。一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在。即， **基类对象是派生类对象的一部分** 。

因为派生类对象不是基类对象的一部分，所以派生类的引用或者指针不能绑定在基类对象上，因为派生类的引用或者指针会发现缺少了很多东西。

即使一个基类指针或者引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换。

#### ……在对象之间不存在类型转换

派生类向基类的自动转换只针对「引用类型」或者「指针类型」， **在派生类类型和基类类型之间并不存在这样的转换** 。也就是说，一个派生类对象不可能彻底转换成一个基类对象，只是基类指针和基类引用能绑定在其对象的基类部分而已。

**<u>当我们初始化或者赋值一个类类型的对象时，实际上是在调用某个函数</u>** 。当执行初始化时，我们调用构造函数；而执行赋值操作时，我们调用赋值运算符。这些成员通常都包含一个参数，类型是该类类型的 `const` 版本的引用。

当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个，显然该构造函数智能处理基类自己的成员。类似的，如果我们将一个派生类对象赋值给一个基类对象，则实际运行的赋值运算符也是基类中定义的那个，该运算符智能处理基类自己的成员。

```C++
Bulk_quote bulk; // 派生类对象
Quote item(bulk); // 使用 Quote::Quote(const Quote&) 构造函数
item = bulk; // 使用 Quote& Quote::operator = (const Quote&)
```

在上述操作中， `Quote` 的构造函数会忽略掉 `Bulk_quote` 的自有部分，所以我们可以说 `bulk` 的 `Bulk_quote` 部分被 **「切掉」** 了。

> **<u>当我们用一个派生类对象为一个基类对象初始化或者赋值时，只有该派生类对象中的基类子对象会被拷贝、移动或者赋值，它的派生类部分将会被忽略掉</u>** 。

#### 关键概念：存在继承关系的类型之间的转换规则

* 从派生类向基类的类型转换只对「指针」或者「引用」类型有效。
* 基类向派生类不存在隐式类型转换。
* 派生类向基类的类型转换也可能会由于访问受限而变的不可行。

通常能够将一个派生类对象拷贝、移动或者赋值给一个基类对象。不过需要注意的是，**这种操作只处理派生类对象的基类部分** 。

## 15.3 虚函数

当使用基类的引用或者指针调用一个虚成员函数时会执行动态绑定。因为直到运行时才能知道到底调用了哪个版本的虚函数， **所以所有虚函数都必须有定义** 。 **<u>我们必须对每一个虚函数提供定义，而不管它是否被使用到了</u>** ，这是因为连编译器都无法确定到底会使用哪个虚函数。

#### 对虚函数的调用可能在运行时才被解析

**当某个虚函数通过指针或者引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本** 。

**<u>「动态绑定」只有当我们通过「指针」或者「引用」调用「虚函数」时才会发生</u>** 。

#### 关键概念：C++ 的多态性

OOP 的核心思想就是「多态性」。 <u>我们将具有继承关系的多个类型称为「多态类型」</u> ，因为我们能使用这些类型的「多种形式」而无需在意其中的差异。「引用」或者「指针」的静态类型与动态类型不同这一事实正是 C++ 语言支持「多态」这个核心思想的根本所在。

> **<u>当且仅当对通过「指针」或者「引用」调用虚函数时，才会在运行时解析函数调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同</u>** 。

#### 派生类中的虚函数

当我们在派生类中覆盖了某个虚函数之后，可以再用一次 `virtual` 关键字指出该函数的性质。然而并非这样做，**因为某个函数一旦被声明成虚函数，则在所有派生类中都是虚函数** 。

一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的 **形参类型** 必须与被它覆盖的基类函数完全一致。而返回类型则不一定必须一致。

> **<u>基类中的虚函数在派生类中隐含的也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配</u>** 。

#### `final` 和 `override` 说明符

使用 `override` 关键字来说明派生类中的虚函数。这么做的好处是使得程序员的意图更加清晰的同时也能让编译器发现一些错误。如果我们使用 `override` 标记了某个函数，但是该函数并没有覆盖已存在的虚函数，此时编译器将报错：

```C++
struct B {
    virtual void f1(int) const;
    virtual void f2();
    void f3();
};

struct D1 : B {
    void f1(int) const override; // 正确：f1 与基类中的 f1 匹配
    void f2(int) override; // 错误：B 中没有形如 f2(int) 的虚函数
    void f3() override; // 错误：B 中的 f3() 不是虚函数
    void f4() override; // 错误：B 中没有形如 f4() 的虚函数
};
```

还可以将某个函数指定为 `final` ，如果将一个函数定义成 `final` 了，则之后任何尝试覆盖该函数的操作都将引发错误：

```C++
struct D2 : B {
    // 从 B 继承 f2() 和 f3() ，覆盖 f1(int)
    void f1(int) const final; // 不允许后续的其他类覆盖 f1(int)
};

struct D3 : D2 {
    void f2(); // 正确：覆盖从间接基类继承而来的 f2
    void f1(int) const override; // 错误：声明为 final 的函数不允许覆盖
};
```

#### 虚函数与默认实参

虚函数也可以拥有默认实参。如果某次函数调用了默认实参，则该实参值由本次调用的静态类型决定。

> 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

#### 回避虚函数的机制

如果我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行某个特定版本。**可以使用「作用域运算符」实现这个目的** ：

```C++
double undiscounted = baseP->Quote::net_price(42);
```

这个代码将强行调用 `Quote` 版本的 `net_price` 。

> 通常情况下，只有成员函数（或者友元）中的代码才需要使用作用域运算符来回避虚函数的机制。

> 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。

## 15.4 抽象基类

假设有以下需求（书店需要支持几种不同策略的折扣）：

* 购买一定数量的书籍之后享受折扣；
* 购买量不超过限额时可以享受折扣，一旦超过限额，超过限额的部分就要按原价支付；
* 购买量超过一定数量之后购买的全部书籍都享受折扣，否则全部不享受。

上面的每个策略都有一个购买量的值和一个折扣值。我们可以定义一个 `Disc_quote` 类来支持不同的折扣策略。其他的表示某种特定策略的类例如 `Bulk_quote` 将分别继承自 `Disc_quote` ，每个派生类通过定义自己的 `net_price` 函数来实现各自的折扣策略。

可见 `Disc_quote` 这个类不需要提供任何具体的折扣策略，它仅仅是作为一个具体折扣策略类的模板类存在。

#### 纯虚函数

在以上需求里，用户根本不会创建一个 `Disc_quote` 类的对象，这个类只是一个通用的折扣概念类，而并非具体的折扣策略。

我们可以将 `net_price` 定义成「纯虚函数」从而实现这个需求，这样做可以清晰明了的告诉用户 `Disc_quote::net_price` 函数没有任何的实际含义。**<u>纯虚函数无需定义</u>** 。通过在函数体的位置（声明语句的分号之前）书写 `= 0` 就可以将一个「虚函数」标记为「纯虚函数」。**<u>`= 0` 标记只能出现在类内部的虚函数声明语句处</u>** ：

```C++
class Disc_quote : public Quote {
public:
    Disc_quote() = default;
    Disc_quote(const std::string& bn, double np, std::size_t qt, double dc) :
        Quote(bn, up), quantity(qt), discount(dc) {  }
    virtual double net_price(std::size_t amount) const = 0;
protected:
    std::size_t quantity = 0; // 使用折扣的购买量
    double discount = 0.0; // 表示折扣的小数值
};
```

**我们可以为纯虚函数提供定义，不过必须定义在类的外部** 。也就是说，我们不能在类的内部为一个 `= 0` 的函数提供函数体。

#### 含有纯虚函数的类是抽象基类

含有（或者未经覆盖直接继承）纯虚函数的类是「 **抽象基类** 」。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能直接创建一个抽象基类的对象。`Disc_quote` 的派生类必须给出自己的 `net_price` 定义，否则它们仍将是抽象基类。

> 我们不能创建抽象基类的对象。

#### 派生类构造函数智能初始化它的直接基类

现在我们需要让 `Disc_quote` 继承 `Quote` ，然后让 `Bulk_quote` 继承 `Disc_quote` 。即：

```
Quote -> Disc_quote -> Bulk_quote
```

```C++
// 当同一书籍的销售量超过某个值时启用折扣
// 折扣的值十一个小于 1 的正的小数值，以此来降低正常销售价格
class Bulk_quote : public Disc_quote {
public:
    Bulk_quote() = default;
    Bulk_quote(const std::string& bn, double up, std::size_t qt, double dc) :
        Disc_quote(bn, up, qt, dc) {  } // 全权委托给 Disc_quote 的构造函数
    // 覆盖基类中的函数版本以实现一种新的折扣策略
    virtual double net_price(std::size_t amount) const override;
    ...
};
```

每个类各自控制其对象的初始化过程。因此，即使 `Bulk_quote` 没有自己的数据成员，它也需要像原来一样提供接受四个参数的构造函数。该构造函数将接受的实参传递给 `Disc_quote` 的构造函数。进行递归式的对象构造。

#### 关键概念：重构

重构负责重新设计类的体系以便将操作或者数据从一个类移动到另外一个类中。

## 15.5 访问控制与继承

每个类还分别控制着其成员对于派生类来说是否「 **可访问** 」。

#### 受保护的成员

一个类使用 `protected` 关键字来声明那些它希望与派生类分享但不想被其他公共访问使用的成员。 `protected` 说明符可以看作是 `public` 和 `private` 中和后的产物：

* 和私有成员类似，**受保护的成员对于类的用户来说是不可访问的** 。
* 和公有成员类似，**受保护的成员对于派生类的成员和友元来说是可访问的** 。
* **<u>派生类的成员或者友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权</u>** 。

```C++
class Base {
protected:
    int prot_mem; //  protected 成员
};

class Sneaky : public Base {
friend void clobber(Sneaky& sk); // 能访问 Sneaky::prot_mem
friend void clobber(Base& bs); // 能访问 Base::prot_mem
    int j; // j 默认是 private
};

// 正确：clobber 能访问 Sneaky 对象的 private 和 protected 成员
void clobber(Sneaky& sk) { sk.j = sk.prot_mem = 0; }
// 错误：clobber 作为 Sneaky 的友元不能直接访问 Base 的 protected 成员
void clobber(Base& bs) { bs.prot_mem = 0; }
```

**<u>派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通基类对象中的成员不具有特殊的访问权限</u>** 。

#### 公有、私有和受保护继承

某个类对其继承而来的成员的访问权限受到两个因素影响：

* 在基类中该成员的访问说明符（ `public` 和 `protected` 可以被访问 ）
* 派生类的派生列表中的访问说明符。

```C++
class Base {
public:
    void pub_mem; // public 成员
protected:
    int prot_mem; // protected 成员
private:
    char priv_mem; // private 成员
};

struct Pub_Derv : public Base {
    // 正确：派生类能访问 protected 成员
    int func() { return prot_mem; }
    // 错误：private 成员对于派生类来说是不可访问的
    char gear() { return priv_mem; }
};

struct Priv_Derv : private Base {
    // private 不影响派生类的访问权限
    int func() { return prot_mem; }
};
```

**派生访问说明符** 的目的是 **<u>控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限</u>** ：

```C++
Pub_Derv d1; // 继承自 Base 的成员是 public 的
Priv_Derv d2; // 继承自 Base 的成员是 private 的
d1.pub_mem(); // 正确：以 public 方式继承来的 public 成员可以访问
d2.pub_mem(); // 错误：虽然是 public 成员，但是是以 private 方式继承来的，所以不可访问
```

**<u>如果继承是公有的，则成员将遵循其原有的访问说明符，此时 `d1` 可以调用 `pub_mem` 。而在 `Priv_Derv` 中， `Base` 的成员是以 `private` 的方式继承来的，所以类的用户不能调用 `pub_mem`</u>** 。

```C++
struct Pub_Derv : public Base {
    // 正确：派生类能访问 protected 成员
    int func() { return prot_mem; }
    // 错误：private 成员对于派生类来说是不可访问的
    char gear() { return priv_mem; }
};

struct Priv_Derv : private Base {
    // private 不影响派生类的访问权限
    int func() { return prot_mem; }
};

struct Derived_from_Public : public Pub_Derv {
    // 正确：Base::prot_mem 在 Pub_Derv 中仍然是 protected 的
    int use_base() { return prot_mem; }
};

struct Derived_from_Private : public Priv_Derv {
    // 错误：Base::prot_mem 在 Priv_Derv 中是 private 的
    // struct Priv_Derv : private Base
    // 因为 Priv_Derv 是以私有的方式继承的 Base ，private 覆盖掉了 protected
    int use_base() { return prot_mem; }
};
```

```
public 方式继承来的成员 :
    public -> public
    protected -> protected
    private -> private
protected 方式继承来的成员 :
    public -> protected
    protected -> protected
    private -> private
private 方式继承来的成员 :
    public -> private
    protected -> private
    private -> private
```

#### 派生类向基类转换的可访问性

假定 `D` 继承自 `B` ：

* **<u>只有当 `D` 以 `public` 继承 `B` 时，用户代码才能使用「派生类向基类」的转换；如果 `D` 继承 `B` 的方式是 `protected` 或者 `private` ，则用户代码不能使用该转换</u>** 。
* **<u>不论 `D` 以什么方式继承 `B` ， `D` 的「成员函数」和「友元」都能使用「派生类向基类」的转换；「派生类」向其「直接基类」的类型转换对于派生类的友元来说永远都是可访问的</u>** 。
* **<u>如果 `D` 继承 `B` 的方式是 `public` 或者 `protected` ，则 `D` 的「派生类成员」和「友元」可以使用 `D` 向 `B` 的类型转换；反之，如果 `D` 继承 `B` 的方式是私有的，则不能使用</u>** 。

> 如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。

#### 关键概念：类的设计与受保护的成员

一个类有两种不同的用户： **<u>普通用户</u>** 和 **<u>类的实现者</u>** 。其中，普通用户编写代码使用类的对象，这部分代码只能访问 `public` 的成员。实现者则负责编写类的成员和友元的代码，成员和友元可以访问 `private` 的成员。

而第三种用户出现在继承时：**<u>派生类</u>** 。普通用户不能访问 `protected` 部分的成员，而派生类即其友元不能访问 `private` 部分的成员。

基类应当将其接口成员声明为 `public` ；同时将属于其实现部分分成两组：

* 可供派生类访问（ `protected` ）。
* 只能有基类以及基类的友元访问（ `private` ）。

#### 友元与继承

**<u>友元关系不能传递，友元关系同样不能继承</u>** 。基类的友元访问派生类成员时没有特殊性，派生类的友元也不能随意访问基类的成员。

当一个类将另一个类声明为友元时，这种友元关系只对作出声明的类有效。

> 不能继承友元关系；每个类负责控制各自成员的访问权限。

#### 改变个别成员的可访问性

如果需要改变派生类继承的某个名字的访问级别，需要使用 `using` 声明。

```C++
class Base {
public:
    std::size_t size() const { return sz; }
protected:
    std::size_t sz;
};

class Derived : private Base {
public:
    using Base::size; // 将 private 继承来的 Base::size 公开
    // 可以被公开访问
protected:
    using Base::sz; // 将 private 继承来的 Base::sz 保护
    // 可以被 Derived 的派生类使用
};
```

**`using` 声明语句中名字的访问权限由该 `using` 声明语句之前的访问说明符来决定** 。

> 派生类只能为那些它可以访问的名字提供 `using` 声明。

#### 默认的继承保护级别

默认派生类运算符也由定义派生类所用的关键字来决定。默认情况下， **<u>使用 `class` 关键字定义的派生类是私有继承；而使用 `struct` 关键字定义的派生类是公有继承</u>** 。

```C++
class Base { ... };
struct D1 : Base { ... }; 等价于 struct D1 : public Base { ... };
class D2 : Base { ... }; 等价于 class D2 : private Base { ... };
```

`class` 同 `struct` 关键字唯一的默认差别就是 **<u>默认成员访问说明符</u>** 以及 **<u>默认派生访问说明符</u>** 。除此之外， **再无不同之处** 。

> **私有派生的类最好显式的将 `private` 声明出来，而不要仅仅依赖于默认设置** 。

## 15.6 继承中的作用域

每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，**<u>「派生类的作用域」嵌套在「基类的作用域」之内</u>** 。 **<u>如果一个名字在派生类的作用域内无法解析，则编译器将继续在外层的基类作用域中寻找该名字的定义</u>** 。

```C++
Bulk_quote bulk;
std::cout << bulk.isbn();
```

名字 `isbn` 的解析将按照下述过程进行：

* `isbn` 是 `Bulk_quote` 的对象 `bulk` 调用的，那么就在 `Bulk_quote` 中寻找（然而并没有找到）。
* `Bulk_quote` 是 `Disc_quote` 的派生类，所以在直接基类 `Disc_quote` 中查找（仍然找不到）。
* 因为 `Disc_quote` 又是 `Quote` 的派生类，所以接着查找间接基类 `Quote` ，此时找到了名字 `isbn` 。故将调用的名字解析为 `Quote::isbn` 。

#### 在编译时进行名字查找

**<u>静态类型决定了该对象的哪些成员是可见的</u>** 。我们能使用哪些成员仍然是由静态类型决定的。

```C++
class Disc_quote : public Quote {
public:
    std::pair<std::size_t, double> discount_policy() const
        { return { quantity, discount }; }
    ...
};

int main(int argc, char* argv[])
{
    Bulk_quote bulk;
    Bulk_quote* bulk_ptr = &bulk; // 静态类型与动态类型一致
    Quote* quote_ptr = &bulk; // 静态类型与动态类型不一致
    bulk_ptr->discount_policy(); // 正确：bulk_ptr 的类型是 Bulk_quote
    quote_ptr->discount_policy(); // 错误：quote_ptr 的类型是 Quote
    return 0;
}
```

**<u>由这个例子我们可以看出，「名字查找」这个动作是在编译期执行的，也就是说是根据变量类型的「静态类型」来确定查找范围的，并且是从当前类开始，逐级向上追溯进行查找（因为「派生类的作用域嵌套在基类作用域中」）</u>** 。

#### 名字冲突与继承

如果派生类重载定义在其基类中的名字，此时， **<u>定义在内层作用域（即派生类）的名字将「隐藏」定义在外层作用域（即基类）的名字</u>** ：

```C++
struct Base {
    Base() : mem(0) {  }
protected:
    int mem;
};

struct Derived : public Base {
    Derived(int i) : mem(i) {  } // 使用 i 初始化 Derived::mem
    // Base::mem 执行默认初始化
    int get_mem() const { return mem; } // 返回 Derived::mem
protected:
    int mem; // 这个 mem 会隐藏 Base::mem
};
```

> 派生类的成员将隐藏同名的基类成员。

#### 通过作用域运算符来使用隐藏的成员

```C++
struct Derived : public Base {
    int get_base_mem() const { return Base::mem; }
    // 使用作用域运算符之后，编译器将直接在指定的作用域中查找对象
};
```

> 除了覆盖继承而来的虚函数之外，派生类「最好不要重用」其他定义在基类中的名字。

#### 关键概念：名字查找与继承

* 首先确定变量的 **静态类型** 。
* 在 **静态类型对应的作用域** 中查找名字；如果找不到，那么 **<u>依次在直接基类中进行递归查找，直至到达继承链的顶端</u>** 。如果这时还找不到指定的名字，则编译器将报错。
* 一旦找到了指定的名字，就进行常规的类型检查以确定本次调用是否合法。
* 若调用合法，则编译器将根据调用的是否是 **虚函数** 而产生不同的代码：
    * 如果调用的是 **虚函数** 且 **通过指针或者引用** 进行的调用， **<u>则依据「动态类型」调用对应版本的虚函数</u>** 。
    * 如果调用的 **不是虚函数** 或者 **通过对象本身** 进行的调用，则产生一个常规的函数调用。

#### 一如往常，名字查找先于类型检查

声明在内层作用域的函数并不会重载声明在外层作用域的函数。因此， **定义在派生类中的函数也不会重载其基类中的成员** 。 **<u>如果派生类的成员与基类的某个成员同名，则派生类将在其作用域内隐藏掉该基类成员，即使派生类成员和基类成员的形参列表不一致，基类成员也会被隐藏掉</u>** 。

#### 虚函数与作用域

**<u>这就是为什么基类与派生类中的虚函数必须有相同的形参列表了</u>** 。假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或者指针调用虚函数了（也就是说，基类函数可能会被隐藏）。

```C++
class Base {
public:
    virtual int func();
};

class D1 : public Base {
public:
    // 隐藏基类的 func() ，这个 func() 不是虚函数
    // D1 继承了 Base::func() 的定义
    int func(int val);    // 形参列表同 Base::func() 不一致
    virtual void func2(); // 是一个新的虚函数，在 Base 中不存在
};

class D2 : public D1 {
public:
    int func(int val); // 非虚函数，隐藏了 D1::func(int val)
    int func();   // 虚函数，继承自 Base::func()
    void func2(); // 虚函数，继承自 D1::func2()
};
```

#### 通过基类调用隐藏的虚函数

```C++
Base bs; D1 d1; D2 d2;

Base* bsp1 = &bs; // 静态 Base 动态 Base
Base* bsp2 = &d1; // 静态 Base 动态 D1
Base* bsp3 = &d2; // 静态 Base 动态 D2

bsp1->func(); // 虚调用，将在运行时调用 Base::func()
bsp2->func(); // 虚调用，将在运行时调用 Base::func()
bsp3->func(); // 虚调用，将在运行时调用 D2::func()

D1* d1p = &d1;
D2* d2p = &d2;

bsp2->func2(); // 非法调用，静态类型的作用域中查不到 func2()
d1p->func2();  // 虚调用，将在运行时调用 D1::func2()
d2p->func2();  // 虚调用，将在运行时调用 D2::func2()
```

因为 `Base` 类中没有 `func2()` 所以第一条语句是非法的，即使当前的指针碰巧指向了一个派生类对象也无济于事（因为首先检查的是静态类型作用域）。

#### 覆盖重载的函数

## 15.7 构造函数与拷贝控制

### 15.7.1 虚析构函数

继承关系对基类拷贝控制最直接的影响就是 **<u>基类通常应该定义一个虚析构函数</u>** 。这样我们就可以动态分配继承体系中的对象了。

有以下情况： <u>如果我们 `delete` 一个 `Quote*` 类型的指针，但是该指针有可能绑定一个 `Bulk_quote` 对象</u> 。在这种情况下，编译器就必须清楚它应当执行 `Bulk_quote` 的析构函数，而不是单纯的执行 `Quote` 的析构函数。这时我们通过 **<u>在基类中将析构函数定义成「虚函数」以确保执行正确的析构函数版本</u>** ：

```C++
class Quote {
public:
    // 如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数
    virtual ~Quote() = default; // 动态绑定析构函数
};
```

析构函数的虚属性也会被继承。**<u>无论 `Quote` 的派生类使用合成的析构函数还是自己定义的析构函数，都将是虚析构函数</u>** 。只要基类的析构函数是虚函数，就能确保我们正确的释放内存。

```C++
Quote* item_ptr = new Quote; // 绑定到一个 Quote 对象上
delete item_ptr; // 正确释放内存
item_ptr = new Bulk_quote; // 绑定到一个 Bulk_quote 对象上
delete item_ptr; // 虚调用 Bulk_quote 的虚构函数，也能正确释放内存
```

**<u>如果基类的析构函数不是虚函数，则 `delete` 一个「指向派生类对象」的「基类指针」将引发未定义行为</u>** ！！！

**<u>一个基类总是需要虚析构函数，而且它能将析构函数设定为虚函数（哪怕什么操作都不执行）</u>** 。

#### 虚析构函数将阻止合成移动操作

**<u>如果一个类定义了析构函数，即使它通过 `= default` 的形式使用了合成的版本，编译器也不会为这个类合成移动操作</u>** 。

### 15.7.2 合成拷贝控制与继承

基类或者派生类的合成拷贝成员，不仅对类本身的成员进行初始化、赋值或者销毁。 **还负责使用直接基类中对应的操作对其基类部分进行初始化、赋值或者销毁** 。

#### 派生类中删除的拷贝控制与基类的关系

这些定义基类的方式可能导致有的派生类成员称为被删除的函数：

* **基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或者析构函数是被删除的，或者不可访问的；则派生类中对应的成员也是删除的** 。
* **基类中有不可访问的，或者删除掉的析构函数，则派生类的合成的默认和拷贝构造函数是被删除的** 。
* **对于移动操作，如果基类中的对应操作是删除的或者不可访问的，那么派生类中也是删除的；如果基类中的析构函数是删除的或者不可访问的，则派生类的移动构造函数也是删除的** 。

#### 移动操作与继承

大多数基类都会定义一个虚析构函数。因此在此默认情况下，基类通常不含有合成的移动操作，而且它的派生类中也没有合成的移动操作。所以当我们确实需要执行移动操作时应该首先在基类中进行定义。我们的 `Quote` 可以使用合成版本，但是必须首先显式的定义这些成员。

```C++
class Quote {
public:
    Quote() = default; // 对成员依次进行默认初始化
    Quote(const Quote&) = default; // 对成员依次进行拷贝
    Quote(Quote&&) = default; // 对成员依次进行移动
    Quote& operator = (const Quote&) = default; // 拷贝赋值
    Quote& operator = (Quote&&) = default; // 移动赋值
    virtual ~Quote() = default; // 虚析构函数
    ...
};
```

### 15.7.3 派生类的拷贝控制成员

派生类的拷贝和移动构造函数在拷贝或者移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，赋值运算符也需要做相同的事情。

但是，派生类的析构函数只负责销毁派生类自己分配的资源。

> 当派生类定义了拷贝或者移动操作时，该操作负责拷贝或者移动包括基类部分成员在内的整个对象。

#### 定义派生类的拷贝或者移动构造函数

我们通常使用对应的基类构造函数初始化对象的基类部分：

```C++
class Base { ... };
class D : public Base {
public:
    // 默认情况下，基类的默认构造函数初始化对象的基类部分
    // 要想使用拷贝或者移动构造函数，我们必须在构造函数初始值列表中
    // 显式的调用该构造函数
    D(const D& d) : Base(d), // 拷贝基类成员
        /* D 的成员的初始值 */ { ... }
    D(D&& d) : Base(std::move(d)), // 移动基类成员
        /* D 的成员的初始值 */ { ... }
};
```

如果我们不像上述那样做，而是直接仅初始化派生类的成员：

```C++
// D 的这个拷贝构造函数很可能是不正确的定义
// 基类部分被默认初始化，而非拷贝
D(const D& d) /* 成员初始值，但是没有提供基类的初始值 */
    { ... }
```

在这个例子中， `Base` 的默认构造函数将被用来初始化 `D` 对象的基类部分。也就是说， **它的 `Base` 成员被赋予了默认值，而 `D` 成员的值则是从其他对象拷贝而来的** 。

> 默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（移动）基类部分， **<u>则必须在派生类的构造函数初始值列表中显式的使用基类的拷贝（移动）构造函数</u>** 。

#### 派生类赋值运算符

```C++
// Base::operator = (const Base&) 不会被自动调用
D& D::operator = (const D& rhs)
{
    Base::operator = (rhs); // 为基类部分赋值
    // 按照过去的方式为派生类的成员赋值
    // 处理自赋值以及释放已有资源等情况
    return *this;
}
```

首先显式的调用基类赋值运算符。基类运算符应当正确的福利自赋值的情况，如果赋值命令正确，则基类运算符将释放掉左侧运算对象的部分旧值，然后利用 `rhs` 为其赋新值。

#### 派生类析构函数

派生类析构函数只负责销毁由派生类自己分配的资源：

```C++
class D : public Base {
public:
    // Base::~Base 被自动调用执行
    ~D() { /* 该处由用户定义清除派生类成员的操作 */ }
};
```

对象销毁的顺序正好同其创建的顺序相反： **<u>派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后</u>** 。

#### 在构造函数和析构函数中调用虚函数

当在构造期间执行基类成员的时候，该派生类对象处于未完成构造的状态。为了能正确处理这种「未完成状态」，编译器认为对象的类型在构造或者析构的过程中是「动态的」。

> 如果构造函数或者析构函数调用了某个虚函数，**<u>则我们应该执行与构造函数或者析构函数所属类型相对应的虚函数版本</u>** 。

### 15.7.4 继承的构造函数

派生类继承基类构造函数的方式是 **提供一条注明了基类名的 `using` 声明语句** 。

```C++
class Bulk_quote : public Disc_quote {
public:
    using Disc_quote::Disc_quote; // 继承 Disc_quote 的构造函数
    double net_price(std::size_t) const;
};
```

当 `using` 声明作用与构造函数时， `using` 声明语句将命令编译器产生代码。对于基类的每个构造函数，编译器都将生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。

```C++
using Disc_quote::Disc_quote;
// 等价于：
Bulk_quote(const std::string& book, double price, std::size_t qty, double disc) :
    Disc_quote(book, price, qty, disc) {  }
```

如果派生类自己有数据成员，这些数据成员将被默认初始化。

#### 继承构造函数的特点

* 针对构造函数的 `using` 声明不会改变该构造函数的访问级别。
* 一个 `using` 声明语句不能指定 `explicit` 或者 `constexpr` 。
* 基类构造函数的默认实参不会被继承。而且，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。
* 如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数不会被继承。
* 默认、拷贝和移动构造函数不会被继承。

