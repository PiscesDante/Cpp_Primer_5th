# 第9章 顺序容器

**顺序容器** 为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖元素的值，而是与元素加入容器时的位置相对应。

## 9.1 顺序容器概述

`std::list` 和 `std::forward_list` 两个容器不支持元素的随机访问，为了访问一个元素，只能遍历整个容器。而且这两个容器的内存开销也很大。

`std::deque` 支持快速的随机访问，操作两端的元素会很快。

`std::array` 对象的大小是固定的。`std::forward_list` 的设计目标是 **达到与最好的手写的单向链表数据结构相当的性能** 。因此，`std::forward_list` 没有 `size` 操作。

> 现代 C++ 程序应当使用标准库容器，而不是更原始的数据结构。

> 通常，使用 `std::vector` 是最好的选择。

> 如果你不确定应该使用哪种容器，那么可以在程序中只使用 `std::vector` 和 `std::list` 公共的操作：使用迭代器，不使用下标操作，避免随机访问。

## 9.2 容器库概览

必须提供额外的信息来生成特定的容器类型。对大多数容器来说，我们需要提供额外的元素类型：

```C++
std::list<int> // 保存 int 对象的 std::list
std::deque<std::string> // 保存 std::string 对象的 std::deque
```

#### 对容器可以保存的元素类型的限制

```C++
// 假定 No_Default 是一个没有默认构造函数的类型
std::vector<No_Default> v1 (10, init); // 正确：提供了元素初始化器
std::vector<No_Default> v2 (10); // 错误：必须提供一个元素的初始化器
```

### 9.2.1 迭代器

迭代器有着公共的接口： **<u>如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的</u>** 。

#### 迭代器范围

一个 **迭代器范围** 由一对迭代器表示，两个迭代器分别指向 **同一个容器** 中的元素或者最后一个元素之后的位置。这两个迭代器通常被称为 `begin` 和 `end` 。

`end` 迭代器指向的是 **最后一个元素之后的位置** 。

这种元素范围被称为 **<u>左闭合区间</u>** ：`[begin, end)` 。

#### 使用左闭合范围蕴含的编程假定

若 `begin == end` ，则范围为空。如果范围非空，`begin` 应指向此范围的第一个元素。

### 9.2.2 容器类型成员

**反向迭代器** ：一种反向遍历容器的迭代器。

通过类型别名，我们可以在不了解容器中元素类型的情况下使用它。如果需要元素类型，可以使用容器的 `value_type` 。如果需要元素类型的一个引用，可以使用 `reference` 或者 `const_reference` 。

```C++
// 为了使用这些类型，我们必须显式的使用其类名
std::list<std::string>::iterator iter;
std::vector<int>::difference_type count;
```

### 9.2.3 `begin` 和 `end` 成员

```C++
std::list<std::string> ls { "Milton", "Shakespeare", "Austen" };
auto it1 = ls.begin(); // iterator
auto it2 = ls.rbegin(); // reverse_iterator
auto it3 = ls.cbegin(); // const_iterator
auto it4 = ls.crbegin(); // const_reverse_iterator
```

当不需要写访问时，使用 `cbegin` 和 `cend` 。

### 9.2.4 容器定义和初始化

每个容器都定义了一个默认构造函数。除了 `std::array` 。

```C++
Class obj; // 默认构造函数
Class obj (another_obj); // 拷贝构造
Class obj = another_obj; // 拷贝构造
Class obj { a, b, c, ... }; // obj 初始化为初始化列表中元素的拷贝
Class obj = { a, b, c, ... }; // obj 初始化为初始化列表中元素的拷贝
Class obj (iter1, iter2); // 使用一对迭代器进行构造
```

#### 将一个容器初始化为另一个容器的拷贝

* 直接拷贝整个容器。
* 拷贝一对迭代器指定的范围。

为了创建一个容器为另一个容器的拷贝，两个 **容器的类型** 以及 **元素的类型** 必须匹配。但是，如果使用迭代器进行构造，就仅仅要求元素的类型必须匹配。

#### 列表初始化

```C++
// 容器有两个元素，用给定的初始化器进行初始化
list<string> authors { "Milton", "Shakespeare" };
```

#### 与顺序容器大小相关的构造函数

```C++
vector<int> ivec (10, -1);
list<string> svec (10, "HI");
forward_list<int> ifl (10); // 10 个元素，每个初始化为 0
deque<string> sdeq (10); // 10 个元素，每个默认初始化
```

如果元素类型没有默认构造函数，除了大小参数之外，还必须指定一个显式的元素初始值。

#### 标准库 `std::array` 具有固定大小

```C++
std::array<int, 42> arr; // 类型为：保存 42 个 int 的数组
std::array<std::string, 10> arr; // 类型为：保存 10 个 string 对象的数组
std::array<std::string, 10>::size_type index; // 数组类型包括元素类型和大小
```

一个默认构造的 `std::array` 是非空的： **它包含了与其大小一样多的元素** 。

### 9.2.5 赋值和 `swap`

赋值运算将其左边容器中的 **全部元素** 替换为右边容器中元素的拷贝。

```C++
std::array<int, 10> arr1 { 1,2,3,4,5 }; // 列表初始化
std::array<int, 10> arr2 { 0 }; // 所有的元素都是 0
arr1 = arr2; // 替换 arr1 中的所有元素
a2 = { 0 }; // 错误：不能将一个花括号列表赋予数组
```

赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而 `swap` 操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效。

#### 使用 `assign` （仅顺序容器）

`assign` 操作 **用参数所指定的元素（的拷贝）替换左边容器中的所有元素** 。

```C++
list<string> names;
vector<const char*> old_style;
names = old_styles; // Error: 容器类型不匹配
names.assign(old_style.cbegin(), old_style.cend());
```

`assign` 的第二个版本接受一个 `int` 和一个 **元素类型值** 。它使用指定数目且具有相同给定值的元素替换容器中原有的元素：

```C++
// 等价于 slist1.clear();
// 后跟 slist1.insert(slist1.begin(), 10, "Hiya");
std::list<std::string> slist1(1);
slist1.assign(10, "Hiya");
```

#### 使用 `swap`

`swap` 操作交换两个相同类型容器的内容。调用 `swap` 之后，两个容器的元素将会交换：

```C++
vector<string> sv1 (10);
vector<string> sv2 (24);
swap(sv1, sv2);
```

> 除了 `array` 之外，`sawp` 不对任何元素进行拷贝、删除或者插入操作，因此可以保证在 **常数** 时间内完成。

**元素不会被移动** ，意味着： **除了 `string` 之外，指向容器的迭代器、引用和指针在 `swap` 操作之后都不会失效** 。

> 统一使用非成员版本的 `swap` 是一个好习惯。

### 9.2.6 容器大小操作

### 9.2.7 关系运算符

关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。

容器内元素的比较优先级大于容器本身的长度比较优先级。

#### 容器的关系运算符使用元素的关系运算符完成比较

只有当其元素类型也定义了相应的比较运算符时，才可以在容器层面进行关系的比较。

## 9.3 顺序容器操作

### 9.3.1 向顺序容器中添加元素

向一个 `vector` 、 `string` 或者 `deque` 插入元素会使所有指向容器的迭代器、引用和指针失效。

#### 使用 `push_back`

```C++
// 从标准输入读取数据，将每个单词放到容器末尾
std::string s;
std::vector<std::string> sv;
while (std::cin >> s) {
    sv.push_back(s); // 这里发生的是值传递
}
```

#### 关键概念：容器元素是拷贝

当我们用一个对象来初始化容器时，或者将一个对象插入到容器中时，实际上放入到容器中的是对象的一个拷贝，而不是对象本身。 **容器中的元素与提供值的对象之间没有任何关联** 。

#### 使用 `push_back`

这个操作将元素插入到容器头部：

```C++
list<int> ilist;
// 将元素添加到 ilist 开头
for (size_t ix = 0; ix != 4; ++ix) {
    ilist.push_front(ix);
}
// ilist : 3, 2, 1, 0
```

#### 在容器中的特定位置添加元素

`insert` 成员提供了更一般的添加功能，它允许我们在容器中任意位置插入 0 个或者多个元素。

```C++
slist.insert(iter, "HELLO"); // 将 HELLO 插入到 iter 指向的元素之前的位置
// 因为迭代器有可能是 end() 
// 所以，为了具有最大的兼容性，设置为将元素插入到迭代器指向的位置的前一个位置
```

#### 插入范围内的元素

```C++
svec.insert(svec.end(), 10, "Anna");
// 将 10 个 "Anna" 插入到 svec 的末尾
```

```C++
// 接受一对迭代器或者一个初始化列表的 insert 版本将给定范围中的元素插入到指定位置之前：
vector<string> sv { "H", "E", "L", "L", "O" };
// 将 sv 的最后两个元素添加到 sl 的开始的位置
sl.insert(sl.begin(), sv.end() - 2, sv.end());
```

如果我们传递给 `insert` 一对迭代器，它们不能指向添加元素的目标容器。

#### 使用 `insert` 的返回值

```C++
std::list<std::string> ls;
auto iter = ls.begin();
while (std::cin >> word) {
    iter = ls.insert(iter, word); // 相当于 push_front 操作
    // insert 返回的迭代器正好指向新插入的元素
}
```

#### 使用 `emplace` 操作

当我们调用一个 `emplace` 成员函数时，则是将参数传递给元素类型的构造函数。 `emplace` 成员使用这些参数在容器管理的内存空间中直接构造元素：

```C++
// 在 c 的末尾构造一个 Sales_data 对象
c.emplace_back("987-0590353403", 25, 15.99); // 使用三个参数的 Sales_data 构造函数
c.push_back("987-0590353403", 25, 15.99); // 错误：没有接受三个参数的 push_back 版本
c.push_back(Sales_data("987-0590353403", 25, 15.99)); // 正确：创建一个临时对象用作拷贝
```

> `emplace` 函数在容器中直接构造元素。传递给 `emplace` 函数的参数必须与元素类型的构造函数相匹配。

### 9.3.2 访问元素

在调用 `front` 和 `back` 成员函数活着解引用 `begin` 和 `end` 返回的迭代器之前，要确保容器非空，如果容器为空，以上的操作将是未定义的。

对一个空容器调用 `front` 和 `back` ，就像使用一个越界的下标一样，是一种严重的程序设计错误。

#### 访问成员函数返回的是引用

```C++
if (!c.empty()) {
    c.front() = 42; // 将 42 赋值给 c 中的第一个元素
    auto& v = c.back(); // 将 v 绑定到 c 中的最后一个元素上
    v = 1024; // c 的尾元素赋值为 1024
    auto v2 = c.back(); // c 的尾元素的值拷贝给 v2
    v2 = 0; // v2 赋值为 0 ，未改变容器中的元素
}
```

#### 下标操作和安全的随机访问

下标运算符接受一个下标参数，返回容器中该位置的元素的引用。给定下标必须在范围之内。保证下标合法是程序员的责任。

如果我们希望确保下标是合法的，可以使用 `at` 成员函数。 `at` 成员函数类似下标运算符，但是如果越界， `at` 会抛出一个 `out_of_range` 异常。

### 9.3.3 删除元素

> 删除 `deque` 中除了首尾之外的任何位置的元素都会使所有的迭代器、引用和指针失效。指向 `vector` 或 `string` 中删除点之后的位置的迭代器、引用和指针都会失效。

> 删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它们是存在的。

#### `pop_front` 和 `pop_back` 成员函数

这两个成员函数返回 `void` 。如果需要弹出元素的值，那么就需要调用 `front` 或者 `back` 来事先保存。

#### 从容器内部删除一个元素

成员函数 `erase` 从容器的指定位置删除元素。要么由迭代器指定，要么由一对迭代器指定。两种形式的 `erase` 都是返回 **指向（最后一个）被删除的元素 之后 位置的迭代器** 。

#### 删除多个元素

### 9.3.4 特殊的 `forward_list` 操作

考虑我们从一个单向链表中删除一个元素时会发生什么。

当在 `forward_list` 中添加或者删除元素时，我们必须关注两个迭代器：

* 指向我们要处理的元素。
* 指向我们要处理的元素的前驱元素。

```C++
std::forward_list<int> flst { 0,1,2,3,4,5,6,7,8,9 };
auto prev = flst.before_begin();
auto curr = flst.begin();
while (curr != flst.end()) {
    if (*curr % 2){
        curr = flst.erase_after(prev);
    } else {
        prev = curr;
        ++curr;
    }
}
```

### 9.3.5 改变容器大小

可以使用 `resize` 来增大或者缩小容器，`std::array` 不支持 `resize` 操作。

如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部：

```C++
list<int> ilist (10, 42); // 10 个 int ：每个值都是 42
ilist.resize(15); // 将 5 个值为 0 的元素添加到 ilist 的末尾
ilist.resize(25, -1); // 将 10 个值为 -1 的元素添加到 ilist 末尾
ilist.resize(5); // 从 ilist 末尾删除 20 个元素
```

> 如果 `resize` 缩小了容器，则指向被删除元素的迭代器、引用和指针都会失效；对 `vector` 、 `string` 或者 `deque` 进行 `resize` 可能导致迭代器、指针和引用失效。

### 9.3.6 容器操作可能使迭代器失效

#### 建议：管理迭代器

由于向迭代器添加元素和删除元素的代码可能会使迭代器失效，因此必须保证改变容器的操作之后都正确的重新定位迭代器。

#### 编写改变容器的循环程序

#### 不要保存 `end` 返回的迭代器

## 9.4 `vector` 对象是如何增长的

#### 管理容量的成员函数

#### `capacity` 和 `size`

`vector` 的实现采用的策略似乎是在每次需要分配新内存空间时将当前的容量翻倍。

> 每个 `vector` 实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是：**只有当迫不得已时才可以分配新的内存空间** 。

## 9.5 额外的 `string` 操作

由于函数过多，本节初次阅读可能令人心烦，因此读者可能希望快速浏览本节。当你了解 `string` 支持哪些类型的操作后，就可以在需要使用一个特定操作时回过头来仔细阅读。

### 9.5.1 构造 `string` 的其他方法

### 9.5.2 改变 `string` 的其他方法

#### `append` 和 `replace` 函数

`append` 操作实在 `string` 末尾进行插入操作的一种简写形式：

```C++
std::string s1 ("C++ Primer");
std::string s2 = s1;
s1.insert(s.size(), " 5th Ed"); // C++ Primer 5th Ed
s2.append(" 5th Ed"); // C++ Primer 5th Ed

// 从位置 11 开始，删除 3 个字符并插入 "Ultimate"
s2.replace(11, 3, "Ultimate");
```

#### 改变 `string` 的多种重载函数

### 9.5.3 `string` 搜索操作

> `string` 搜索函数返回 `string::size_type` 值，该类型是一个无符号类型。因此，**用一个 `int` 或者其他带符号类型来保存这些函数返回值不是一个好主意** 。

#### 指定哪里开始搜索

#### 逆向搜索

### 9.5.4 `compare` 函数

根据 `s` 是等于、大于还是小于参数指定的字符串， `s.compare` 返回 `0` 、正数或者负数。

### 9.5.5 数值转换

新标准下引入了多个函数，可以实现数值数据与标准库 `string` 之间的转换：

```C++
int i = 42;
std::string s = std::to_string(i); // 将整数 i 转换为字符表示形式
double d = stod(s); // 将字符串 s 转换为浮点数
```

> 如果 `string` 不能转换为一个数值，这些函数抛出一个 `invalid_argument` 异常。如果转换得到的数值无法用任何类型来表示，则抛出一个 `out_of_range` 异常。

## 9.6 容器适配器

**适配器** 是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上， **<u>一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样</u>** 。一个容器适配器接受一种已有的容器类型，使其看起来像一种不同的类型。

> `std::stack` 接受一个顺序容器，并使其操作起来像一个栈一样。

#### 定义一个适配器

每个适配器都定义两个构造函数： **默认构造函数** 创建一个空对象， **接受一个容器的构造函数** 拷贝该容器来初始化适配器。

```C++
std::stack<int> stck (deq);
```

默认情况下， `std::stack` 和 `std::queue` 是基于 `std::deque` 实现的。`std::priority_queue` 是在 `std::vector` 之上实现的。我们可以在创建一个适配器时指定一个顺序容器作为第二个类型参数，来覆盖默认的容器类型：

```C++
// 在 std::vector 上实现的 std::stack
std::stack<int, std::vector<int>> stck (ivec);
```

所有适配器都要求容器具有 **<u>添加、删除以及访问尾元素的能力</u>** 。

#### 栈适配器

#### 队列适配器