# 第5章 语句

## 5.1 简单语句

C++ 语言中的大多数语句都以分号结束。一个表达式末尾加上分号就变成了 **表达式语句** 。表达式语句的作用是执行表达式并且丢弃求值结果：

```C++
int x = 10;
x + 5; // 求值得到 15，然后将这个值丢弃，这个表达式并没有什么作用
std::cout << x; // 有用的表达式
```

#### 空语句

空语句中只含有一个单独的分号：

```C++
; // 空语句
```

如果程序中某个地方语法上需要一条语句但是逻辑上并不需要，就需要使用空语句，否则会产生编译错误。

使用空语句时应当加上注释，否则后来人会很困惑代码的含义。

#### 别漏写分号，也别多写分号

```C++
ival = v1 + v2;; // 正确：多了一条空语句

while (true); { // 错误：这个循环会永远的执行下去
    if (x == 5) break; // 这里并不算是循环的一部分
}
```

#### 复合语句（块）

**复合语句** 是指 <u>用花括号括起来的语句和声明序列</u> ，复合语句也被称为 **块（ block ）** 。一个块就是一个作用域。名字在有限的区域内可见，该区域从名字定义处开始，到名字所在的块的结尾为止。

块不以分号作为结束。

## 5.2 语句作用域

定义在控制结构当中的变量只在相应的语句内部可见，一旦语句结束，变量也就超出了其作用范围：

```C++
// 在每次循环开始时重新声明 i
while (int i = get_num()) std::cout << i << std::endl;
i = 0; // 错误：在循环体外部无法访问 i
```

## 5.3 条件语句

* `if` 语句：根据条件控制流。
* `switch` 语句：计算一个整型表达式的值，然后根据取值从几条路径中选择一条。

`if` 语句中的条件都必须使用括号包起来。条件可以是一个表达式，也可以是一个初始化了的变量声明。不管是表达式还是变量，其类型都必须能转换成布尔类型。

#### 使用 `if - else` 语句

#### 嵌套 `if` 语句

#### 注意使用花括号

程序中本来有几条语句应该作为一个块来执行，但是忘了使用花括号将其变成一个复合语句。

为了避免这种问题， **有些编码风格要求在 `if` 或者 `else` 后必须加上花括号，哪怕只有一条语句** 。

#### 悬垂 `else`

C++ 语言中，**<u>`else` 与离它最近的尚未匹配的 `if` 进行匹配</u>** ，从而消除了二义性：

```C++
if (grade % 10 >= 3) // 1
    if (grade % 10 >= 7) // 2
        letter_grade += '+';
else // 这个 else 实际上匹配的是 2，虽然从缩进上看试图匹配 1
    letter_grade += '-';
```

#### 使用花括号控制执行路径

```C++
if (grade % 10 >= 3){
    if (grade % 10 >= 7) {
        letter_grade += '+';
    }
} else {
    letter_grade += '-';
}
```

### 5.3.2 `switch` 语句

`switch` 语句首先对括号里的表达式求值，该表达式紧跟在关键字 `switch` 后面，可以是一个初始化的变量声明。表达式的值转换成整数类型，然后与每个 `case` 标签的值比较。

如果表达式和某个 `case` 标签的值匹配成功，程序从该标签之后的第一条语句开始执行，直到到达了 `switch` 的结尾或者遇到一条 `break` 语句为止。

`break` 语句的作用是：**中断当前的控制流** 。

`case` 关键字和它对应的值一起被称为 **`case` 标签** 。`case` 标签必须是 **整型常量表达式** 。

```C++
char ch = get_val();
int ival = 42;
switch (ch) {
    case 3.14 : // 错误：case 标签不是一个整数
    case ival : // 错误：case 标签不是一个常量
    ...
}
```

#### `switch` 内部的控制流

如果某个 `case` 标签匹配成功，将从该标签开始往后顺序执行所有的 `case` 分支，除非程序显式的中断了这一过程，否则直到 `switch` 的结尾处才会停下来。

#### 漏写 `break` 容易引发缺陷

有一种常见的错觉是程序只是执行匹配成功的那个 `case` 分支的语句。尽管 `switch` 语句不是非得在最后一个标签后面写上 `break` ， **但是为了安全起见，最好这么做** 。

#### `default` 标签

如果没有一个 `case` 标签能匹配上传入的表达式，程序将执行紧跟在 `default` 标签后面的语句。即使不准备在 `default` 标签下做任何工作，定义一个 `default` 标签也是有用的。这是一个良好的习惯。当不准备在任何标签后执行操作的情况下，应当在 `default` 标签后跟上一条 **空语句** 或者 **空块** 。

#### `switch` 内部的变量定义

如果在某处一个带有初始值的变量位于作用域之外，在另一处位于该作用域之内，则从迁移处跳转到后一处的行为是非法行为。

```C++
case true :
    string file_name; // 错误：控制流绕过一个隐式的初始化的变量
    int ival = 0; // 错误：控制流绕过一个显式的初始化的变量
    int jval; // 正确：jval 没有被初始化
    break;
case false :
    // 正确：jval 虽然在作用域内，但是它没有被初始化
    jval = next_num(); // 正确：给 jval 一个初始值
    if (file_name.empty()) // file_name 在作用域内，但是没有被初始化
```

假设上述代码合法，则一旦控制流直接跳到 `false` 分支，就同时略过了变量 `file_name` 和 `ival` 的初始化过程。而在尚未初始化的情况下使用显然是不合法的。

这里只需要记住，**尽量不要在 `case` 分支中声明变量** 。当然，如果确实需要为某个 `case` 分支定义并初始化一个变量，应当把变量定义在块中：

```C++
case true : {
    ...
} break;
case false : {
    std::string s { "HELLO" }; // 这样就没问题
} break;
```

## 5.4 迭代语句

`while` 和 `for` 语句在执行循环体之前检查条件，`do while` 语句先执行循环体，然后再检查条件。

### 5.4.1 `while` 语句

`while (condition) statement;`

**定义在 `while` 条件部分或者 `while` 循环体内的变量每次迭代都经历从创建到销毁的全过程** 。

#### 使用 `while` 循环

### 5.4.2 传统的 `for` 语句

基本形式：

```C++
for (inti_statement; condition; expression)
    statements;
```

`for` 关键字及其括号里的部分称为 **语句头** 。

* `inti_statement` ：负责初始化一个值，这个值将随着循环的进行而改变。
* `condition` ：只要为真，那么就会执行循环体。
* `expression` ：修改 `inti_statement` 初始化的变量。

**`for` 语句头中定义的对象只在 `for` 循环体内可见** 。

#### `for` 语句头中的多重定义

虽然可以定义多个对象，但是 `inti_statement` 智能有一条声明语句，因此， **所有变量的基础类型必须相同** 。

#### 省略 `for` 语句头中的某些部分

```C++
for (;;) { ... } // 相当于 while (true) { ... }
```

**省略 `condition` 部分的效果等价于在条件部分写了一个 `true`** 。

### 5.4.3 范围 `for` 语句

基本语法形式：

```C++
for (declaration : expression)
    statement
```

* `expression` ：表示的必须是一个序列，比如使用花括号括起来的初始值列表。
* `declaration` ：定义一个变量，类型就是序列中元素的类型。如果需要对序列中的元素执行操作，必须声明为引用类型。

范围 `for` 语句的定义来源于与之等价的传统 `for` 语句：

```C++
for (
    auto beg = v.begin(), end = v.end();
    beg != end;
    ++beg;
) {
    auto& r = *beg;
    r *= 2;
}
```

### 5.4.4 `do while` 语句

`do while` 语句先执行循环体后检查条件。不管条件值如何，都会至少执行一次循环体：

```C++
do {
    statement
} while (condition); // 这里有一个分号
// condition 不能为空
// condition 使用的变量必须定义在循环体之外
```

## 5.5 跳转语句

### 5.5.1 `break` 语句

`break` 语句负责终止离它最近的 `while` 、`do while` 、`for` 或者 `switch` 语句，并从这些语句之后的第一条语句开始继续执行。

### 5.5.2 `continue` 语句

终止最近的循环中的当前迭代并且立即开始下一次迭代。

### 5.5.3 `goto` 语句

从 `goto` 语句无条件跳转到同一函数内的令一条语句。

基本形式：

```C++
goto label;
```

其中，`label` 是用于标识一条语句的标识符。**标签语句** 是一种特殊的语句，在它之前有一个标示符以及一个冒号：

```C++
end: return; // 带标签语句，可以作为 goto 的目标
```

标签独立于变量或者其他标示符的名字。`goto` 语句和控制权转向的那条带标签的语句必须位于同一个函数之内。

## 5.6 `try` 语句块和异常处理

**异常** 是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。当程序的某部分检测到一个它无法处理的问题时，需要用到异常处理。此时，出现故障的部分应当发出某种信号，然后检测出问题的部分也就完成了任务。

异常处理机制为程序中异常检测和异常处理这两个部分的协作提供支持。异常处理包括：

* **`throw` 表达式** ：异常检测部分使用 `throw` 表达式来表示它遇到了无法处理的问题。我们说 `throw` 引发了异常。
* **`try` 语句块** ：异常处理部分使用 `try` 语句块处理异常。`try` 语句块以关键字 `try` 开始，并以一个或者多个 `catch` 子句结束。`try` 语句块中代码抛出的异常通常会被某个 `catch` 子句处理。因为 `catch` 子句 **处理** 异常，所以它们也被称为 **异常处理代码** 。
* **异常类** ：用于在 `throw` 表达式和相关的 `catch` 子句之间传递异常的具体信息。

### 5.6.1 `throw` 表达式

```C++
Sales_item item1, item2;
std::cin >> item1 >> item2;
if (item1.isbn() == item2.isbn()) {
    std::cout << item1 + item2 << std::endl;
    return 0; // 成功
} else {
    std::cerr << "Data must refer to same ISBN" << std::endl;
    return -1; // 表示失败
}
```

然而在上述程序中，应当把对象相加的代码和用户交互的代码分离开来：

```C++
#include <stdexcept> // std::runtime_error

Sales_item item1, item2;
std::cin >> item1 >> item2;
if (item1.isbn() != item2.isbn()) {
    throw std::runtime_error("Data must refer to same ISBN");
}
std::cout << item1 + item2 << std::endl;
return 0;
```

### 5.6.2 `try` 语句块

```C++
try {
    ...
} catch (exception-declaration) {
    ...
} catch (...) {
    ...
} ...
```

`try` 语句块内声明的变量在块外部无法访问，特别是在 `catch` 子句内也无法访问。

#### 编写处理代码

```C++
while (std::cin >> item1 >> item2) {
    try {
        // 执行添加两个 Sales_item 对象的代码
        // 如果添加失败，代码抛出一个 runtime_error 异常
    } catch (runtime_error) {
        // 提醒用户两个 ISBN 必须一致，询问是否重新输入
        std::cout << err.what() << std::endl;
        std::cout << "Try Again? Enter [y]/n: ";
        char ch = 'y';
        std::cin >> ch;
        if (!std::cin || c == 'n') break;
    }
}
```

#### 函数在寻找处理代码的过程中退出

当异常被抛出时，首先搜索抛出该异常的函数。如果没有找到匹配该 `catch` 的子句，终止该函数，并在调用该函数的函数中继续搜索 `catch` 子句。如果还是没有找到匹配的 `catch` 子句，这个调用者函数也会被终止，然后继续搜索调用者函数的调用者函数，以此类推，然者程序的执行路径逐层上溯，直到找到适当类型的 `catch` 子句为止。

如果最终都没有找到对应的 `catch` 子句，程序转到名为 `terminate` 的标准库函数。执行该函数将导致程序非正常退出。

对于那些没有任何 `try` 语句定义的异常，也是按照这个类似的方式处理。如果一段程序没有 `try` 语句且发生了异常，系统就会调用 `terminate` 函数并且终止当前程序的执行。

### 5.6.3 标准异常

* `<exception>` ：定义了最通用的异常类 `exception` 。它只报告异常的发生，不提共任何额外的信息。
* `<stdexcept>` ：定义了几种常用的异常类。
* `new` ：定义了 `bad_alloc` 异常类型。
* `type_info` ：定义了 `bad_cast` 异常类型。

我们只能以默认初始化的方式来初始化 `exception` 、`bad_alloc` 和 `bad_cast` 对象，禁止为这些对象提供初始值。

创建其他的异常对象时，反而必须提供初始化值，例如 `string` 对象或者 C 风格的字符串。

异常类型只定义了一个名为 `what` 的成员函数，该函数没有任何参数，返回一个指向 C 风格字符串的 `const char*` 。该字符串提供关于异常的文本信息。