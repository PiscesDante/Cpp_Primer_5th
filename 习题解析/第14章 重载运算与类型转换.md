# 14.1 节练习

## 练习 14.1

> 在什么情况下重载的运算符与内置的运算符有所区别？在什么情况下重载的运算符又与内置的运算符一样？

解答：

当在内置的运算符和我们自己的操作之间有逻辑映射关系时，运算符重载的效果是一样的；反之就有所区别。

## 练习 14.2

> 为 `Sales_data` 编写重载的输入、输出、加法和复合赋值运算符。

解答：

```C++
class Sales_data {
friend std::istream& operator >> (std::istream& is, Sales_data& rhs);
friend std::ostream& operator << (std::ostream& os, Sales_data& rhs);
public:
    ...
    Sales_data operator + (const Sales_data& rhs)
    {
        if (book_no == rhs.book_no) {
            Sales_data ret;
            ret.book_no = book_no;
            ret.units_sold = units_sold + rhs.units_sold;
            ret.revenue = revenue + rhs.revenue;
            return ret;
        } else {
            throw std::execption("Error: Different ISBN.");
        }
    }

    Sales_data& operator += (const Sales_data& rhs)
    {
        if (book_no == rhs.book_no) {
            units_sold += rhs.units_sold;
            revenue += rhs.revenue;
        }
        return *this;
    }
    ...
};

std::istream& operator >> (std::istream& is, Sales_data& rhs)
{
    is >> rhs.book_no;
    is >> rhs.units_sold;
    is >> rhs.revenue;
    return is;
}

std::ostream& operator << (std::ostream& os, Sales_data& rhs)
{
    os << rhs.book_no << " ";
    os << rhs.units_sold << " ";
    os << rhs.revenue;
    return os;
}
```

## 练习 14.3

> `std::string` 和 `std::vector` 都定义了重载的 `==` 以比较各自的对象，假设 `svec1` 和 `svec2` 是存放 `string` 的 `vector` ，确定在下面的表达式中分别使用了哪个版本的 `==` ？

解答：

```C++
(a) "cobble" == "stone";  // const char* 的 ==
(b) svec1[0] == svec2[0]; // std::string 的 ==
(c) svec1 == svec2;       // std::vector 的 ==
(d) svec1[0] == "stone";  // std::string 的 ==
```

## 练习 14.4

> 如何确定下列运算符是否应该是类的成员？

解答：

* a) `%` : 取余运算符，可能会作用于右值，所以不应该是类的成员。
* b) `%=` : 取余复合运算符，只能作用于左值并且应当返回左值，所以应当是类的成员。
* c) `++` : 递增运算符，应当是类的成员。
* d) `->` : 箭头运算符必须是类的成员。
* e) `<<` : 如果是输入输出运算符，则不应是类的成员。
* f) `&&` : 逻辑与一般不应当重载，但是如果非要重载，因为对称的性质，不应是类的成员。
* g) `==` : 一般来说应当是成员。
* h) `()` : 调用运算符必须是成员。

## 练习 14.5

> 在 7.5.1 节的练习 7.40 （第 261 页）中，编写了下列类中某一个的框架，请问在这个类中应该定义重载的运算符吗？如果是，请写出来。

解答：

```C++
class Book {
friend std::istream& operator >> (std::istream& is, Book& rhs);
friend std::ostream& operator << (std::ostream& os, Book& rhs);
public:
    Book operator + (const Book& rhs);
    Book& operator += (const Book& rhs);
};
```