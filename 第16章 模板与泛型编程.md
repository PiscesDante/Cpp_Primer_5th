# 第16章 模板与泛型编程

**面向对象编程** 和 **泛型编程** 都能处理在编写程序时 **不知道类型** 的情况。不同之处在于： **<u>OOP 能处理类型在程序运行之前都未知的情况；而在泛型编程中，编译时就能获知类型了</u>** 。当我们编写一个泛型程序时，是独立于任何特定类型来编写代码的。使用一个泛型程序时，我们提供类型或者值，程序实例可以在其上运行。

**<u>模板是泛型编程的基础</u>** 。一个模板本质上就是 **<u>创建类或者函数的蓝图或者公式</u>** 。我们在使用泛型类或者泛型函数时，需要提供足够的信息，将蓝图转换称为特定的类或者函数。

## 16.1 定义模板

当编写一个函数来比较两个值，我们可能需要定义多个重载函数：

```C++
int compare(const std::string& v1, const std::string& v2)
{
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}

int compare(const double v1, const double v2)
{
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

以上两个函数除了参数的类型，函数体是完全相同的。如果针对每种希望比较的类型都不得不重复定义相同的函数体，那将非常麻烦而且易错（而且，我们不可能为所有的要比较的类型写比较函数）。

### 16.1.1 函数模板

定义通用的「函数模板」，而不是为每个类型都定义一个新函数。 **<u>一个函数模板就是一个公式，可以用来生成特定的函数版本</u>** 。 `compare` 的模板版本：

```C++
template <typename T>
int compare(const T& v1, const T& v2)
{
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

**<u>模板定义以关键字 `template` 开始，后跟一个「模板参数列表」，这是一个逗号分隔的，一个或者多个「模板参数」的列表，用尖括号 `<>` 包围起来</u>** 。

> 在模板定义中，模板参数列表不能为空。

模板参数表示在类或者函数定义中用到的类型或者值。当使用模板时，我们（隐式或者显式）的指定 **模板实参** ，将其绑定到模板参数上。

我们的 `compare` 函数声明了一个名为 `T` 的类型参数。在 `compare` 中，我们用名字 `T` 表示一个类型。而 `T` 表示的实际类型则在编译时根据 `compare` 的使用情况来定。

#### 实例化模板

**<u>当我们调用一个函数模板时，编译器用函数实参来为我们推断模板实参</u>** 。当我们调用 `compare` 时，编译器使用实参的类型来确定绑定到模板实参的类型。

```C++
std::cout << compare(1, 0) << std::endl; // T 为 int
```

编译器用推断出的模板实参来为我们 **实例化** 一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板参数代替对应的模板参数来创建出一个新的「实例」：

```C++
// 实例化出 int compare(const int&, const int&)
std::cout << compare(1, 0) << std::endl; // T 为 int
// 实例化出 int compare(const std::vector<int>&, const std::vector<int>&)
std::vector<int> v1 { 1,2,3 }, v2 { 3,4,5 };
std::cout << compare(v1, v2) << std::endl; // T 为 std::vector<int>
```

这些编译器生成的版本通常被称为 **模板的「实例」** 。

#### 模板类型参数

类型参数可以看作类型说明符，就像内置类型或者类类型说明符一样使用。**<u>类型参数可以用来指定返回类型或者函数的参数类型，以及在函数体内用用变量声明或者类型转换</u>** ：

```C++
// 正确：返回类型和参数类型相同
template <typename T>
T foo(T* ptr)
{
    T temp = *ptr; // temp 的类型将是指针 ptr 指向的类型
    ...
    return temp;
}
```

**<u>类型参数之前必须使用关键字 `class` 或者 `typename`</u>** ：

```C++
// 错误：类型参数 U 之前必须加上关键字 class 或者 typename
template <typename T, U> ...
```

在模板参数列表中，这两个关键字含义相同，可以互换使用。一个模板参数列表中可以同时使用这两个关键字：

```C++
// 正确：在模板参数列表中，typename 和 class 没有什么不同
template <typename T, class U> calc(const T&, const U&);
```

> 关键字 `typename` 比 `class` 更加直观；而且 `typename` 更清楚的指出随后的名字是一个类型名。

#### 非类型模板参数

除了类型参数，还可以在模板中定义 **非类型参数** 。 **<u>一个非类型参数表示一个值</u>** ，而非一个类型。 **当一个模板被实例化时，非类型参数被一个用户提供的或者编译器推断出的值所代替** 。这些值必须是常量表达式，从而允许编译器在编译期实例化模板。

```C++
// 编写一个 compare 版本来处理字符串字符串字面量
// 这种字面常量是 const char 的数组
// 不能拷贝数组，所以将参数定义为数组的引用
// 由于希望能比较不同长度的数组，因此定义了两个非类型的参数

template <unsigned N, unsigned M>
int compare(const char (&s1)[N], const char (s2)[M])
    { return strcmp(s1, s2); }
```

当我们调用这个版本的 `compaare` 时：

```C++
compare("Hi", "WORLD");
```

编译器会使用字面常量的大小来代替 `N` 和 `M` ，从而实例化模板。编译器会在字符串字面量的末尾插入一个空字符 `\0` 作为终结符，因此编译器会实例化出如下版本：

```C++
int compare(const char (&s1)[3], const char (&s2)[6])
    { return strcmp(s1, s2); }
```

**<u>一个非类型参数可以是一个整形，或者十一个指向对象或者函数类型的指针（左值引用）。绑定到非类型整形参数的实参必须是一个常量表达式。绑定到指针或者引用的非类型参数的实参必须具有静态的生存期</u>** 。我们不能使用一个普通的局部变量或者动态对象作为指针或者引用非类型模板参数的实参。

**在模板定义内，模板非类型参数是一个常量值** 。在需要常量表达式的地方，可以使用非类型参数。

> 非类型模板参数的模板实参必须是常量表达式。

#### `inline` 和 `constexpr` 的函数模板

函数模板可以声明为 `inline` 或者 `constexpr` 的：

```C++
// 正确：inline 说明符跟在参数模板列表之后
template <typename T>
inline T min(const T&, const T&);
```

#### 编写类型无关的代码

编写泛型代码的两个重要原则：

* 模板中的函数参数是 `const` 的引用。
* 函数体中的条件判断仅使用 `<` 比较运算。

通过将函数参数设定为 `const` 的引用，我们保证了函数 **可以用于不能拷贝** 的类型。而且 `compare` 用于处理大对象，这种设计策略将会使函数运行的更快。

单纯使用 `<` 运算符，可以降低 `compare` 函数对要处理的类型的要求，即这些类型仅需要支持 `<` 运算符即可。

实际上，如果我们真的关心类型无关和可移植性，可能需要使用 `less` 来定义我们的函数：

```C++
// 即使用于指针也正确的 compare 版本
template <typename T>
int compare(const T& v1, const T& v2)
{
    // std::less<Typename> 是行为类似函数的对象
    if (std::less<T>()(v1, v2)) return -1;
    if (std::less<T>()(v2, v1)) return 1;
    return 0;
}
```

> 模板程序应该尽量减少对实参类型的要求。

#### 模板编译

**<u>当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用模板时，编译器才生成代码</u>** 。

通常， **<u>调用函数时，编译器只需要掌握函数的声明</u>** 。类似的， **<u>当我们使用一个类类型对象时，类定义是必须是可用的，但是成员函数的定义不必已经出现</u>** 。因此我们将类定义和函数声明放在头文件中，而普通函数和类的成员定义放在源文件中。

模板则不同： **<u>为了生成一个实例化模板，编译器需要掌握「函数模板」或者「类模板成员函数」的定义</u>** 。因此，模板的头文件通常既包含声明，也包含定义。也就是说，如果是模板类或者模板函数，声明和定义写在一起就行了。

#### 关键概念：模板和头文件

模板包含两种名字：

* 那些不依于模板参数的名字。
* 那些依赖于模板参数的名字

当使用模板时， **所有不依赖于模板参数的名字必须都是可见的** ，这是由模板的提供者来保证的。而且，模板的提供者必须保证，**当模板被实例化时，模板的定义，包括类模板的成员的定义，也必须是可见的** 。

**用来实例化模板的所有函数、类型以及类型相关联的运算符的声明都必须是可见的** ，这是由模板的用户来保证的。

模板的设计者应该提供一个头文件，**包含「模板定义」以及「在类模板或者成员定义中用到的所有名字的声明」** 。模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。

#### 大多数编译错误在实例化期间报告

**模板直到实例化时才会生成代码** ，这个特性影响了我们何时才会获知模板内代码的编译错误。编译器会在三个阶段报告错误：

* 编译模板时：语法错误，比如分号或者变量名的拼写。
* 使用模板时：实参数目是否正确。类型匹配等等。
* **模板实例化时** ：这个阶段才能发现类型相关的错误。

> **<u>保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确的工作</u>** ，是模板调用者的责任。

