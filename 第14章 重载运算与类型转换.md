# 第14章 重载运算与类型转换

## 14.1 基本概念

重载的运算符是具有特殊名字的函数： **<u>它们的名字由关键字 `operator` 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体</u>** 。

「重载运算符函数」的参数数量与该运算符作用的运算对象数量一样多。除了重载的函数调用运算符 `operator ()` 之外，其他的重载运算符不能含有默认实参。

如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的 `this` 指针上。 **因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个** 。

```C++
// 错误：不能为 int 重定义内置的运算符
int operator + (int lhs, int rhs);
```

**我们只能重载已有的运算符，而无权发明新的运算符号** 。

#### 直接调用一个重载的运算符函数

```C++
// 一个非成员运算符函数的等价调用
data1 + data2;             // 普通的表达式
operator + (data1, data2); // 等价的函数调用
```

以上两个形式的调用是等价的。

```C++
data1 += data2;            // 基于「调用」的表达式
data1.operator += (data2); // 对成员运算符函数的等价调用
```

#### 某些运算符不应该被重载

因为有些运算符，特别是 **逻辑于运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则无法保留下来** 。因此，不建议重载它们。比方说重载的 `&&` 可能会没有短路求值的操作。

**<u>同样地，我们也不重载逗号运算符和取地址运算符</u>** 。

> 通常情况下，不应当重载逗号、取地址、逻辑与和逻辑或运算符。

#### 使用与内置类型一致的含义

* 如果类执行输入输出操作，则定义位移运算符使其与内置类型输入输出保持一致。
* 如果检查相等性的操作，则定义 `operator == ` ；如果类有了 `operator == ` ，意味着它通常也应当有 `operator !=` 。
* 如果一个类包含一个内在的单序比较操作，则定义 `operator < ` ；如果类有了 `operator < ` ，则它也应该有其他关系的操作符。
* 重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容。

#### 提示：尽量明智的使用运算符重载

* 把二元运算符映射到类类型的一个类似操作上可以极大的简化记忆。
* 当在内置的运算符和我们自己的操作之间存在逻辑映射关系时，运算符重载的效果最好。
* 只有当操作的含义对于用户来说清晰明了时才使用运算符。如果用户对运算符可能有几种不同的理解，则使用这样的运算符将产生二义性。

#### 赋值和复合赋值运算符

赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧运算对象的一个引用。重载的赋值运算符应当 **继承** 而非违背其内置版本的含义。

#### 选择作为成员或者非成员

* 赋值（ `=` ），下标（ `[]` ），调用（ `()` ）和成员访问箭头（ `->` ）运算符必须是成员。
* 复合赋值运算符一般来说是成员函数，但非必须。
* **改变对象状态的运算符或者与给定类型密切相关的运算符，通常应当是成员** 。
* 具有对称性的运算符可能转换任意一端的的运算对象，因此通常应当是非成员函数。

**当我们把运算符定义成成员函数时，它的<u>左侧运算对象</u>必须是运算符所属类的一个对象** 。

```C++
std::string s = "World";
std::string t = s + "!"; // 正确：我们能把一个 const char* 加到一个 std::string 对象中
std::string u = "hi" + s; // 如果 + 是 std::string 的成员函数，则产生错误
```

