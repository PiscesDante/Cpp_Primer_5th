# 第15章 面向对象程序设计

面向对象程序设计基于三个概念： **数据抽象** 、**继承** 和 **动态绑定** 。

继承和动态绑定对程序的编写有两方面的影响：

1. 我们可以更容易的定义与其他类「大同小异」的新类。
2. 使用这些大同小异的类编写程序的时候，可以在一定程度上忽略掉它们的区别。

## 15.1 OOP：概述

**面向对象程序设计** 的核心思想是：

* **数据抽象** ：将类的接口和实现分离；
* **继承** ：可以定义相似的类型并对其相似关系建模；
* **动态绑定** ：可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象；

#### 继承

通过 **继承** 联系在一起的类构成一种层次关系。通常在这个关系的根部有一个 **基类** ，而其他类则直接或间接的从基类继承而来，这些继承得到的类称为 **派生类** 。 **基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员** 。

建模：定义一个名为 `Quote` 的类作为基类。 `Quote` 的对象表示按原价销售的书籍。 `Quote` 派生出一个名为 `Bulk_quote` 的类，它表示可以打折销售的书籍。

这些类将包含下面的两个成员函数：

* `isbn()` ：返回书籍的 `isbn` 编号。仅定义在 `Quote` 类中。
* `net_price(std::size_t)` ：返回书籍的实际销售价格，前提是用户购买这个书籍达到一定的数量，这个操作显然是类型相关的。

在 C++ 语言中，基类将 **类型相关的函数** 与 **派生类不做改变直接继承的函数** 区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就需要将这样的函数声明为 **「虚函数」** ：

```C++
class Quote {
public:
    std::string isbn() const;
    // Quote 希望继承它的派生类自己完成 net_price 的定义
    virtual double net_price(std::size_t amount) const;
};
```

派生类必须通过使用 **「类派生列表」** 来明确指出它是从哪些基类派生而来的。类派生列表的形式是：**首先一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有「访问说明符」** ：

```C++
class Bulk_quote : public Quote { // Bulk_quote 继承了 Quote
public:
    double net_price(std::size_t amount) const override;
};
```

因为 `Bulk_quote` 在它的派生列表中使用了 `public` 关键字，因此我们完全可以把 `Bulk_quote` 的对象当成 `Quote` 的对象来使用。

派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 `virtual` 关键字，但并不是非要这样做。**C++ 新标准允许派生类显式的注明它将使用哪个成员函数改写基类的虚函数** ，具体措施就是在形参列表之后加上关键字 `override` 。

#### 动态绑定

使用该特性，我们能用同一段代码分别处理 `Quote` 对象和 `Bulk_quote` 对象 。

```C++
// 计算并且打印销售给定数量的某种书籍所得的费用
double print_total(std::ostream& os, const Quote& item, std::size_t amount)
{
    // 根据传入的 item 形参的对象类型调用 Quote::net_price
    // 或者 Bulk_quote::net_price
    double ret = item.net_price(amount);
    os << "ISBN: " << item.isbn() << " | "; // 调用 Quote::isbn()
    os << "# Sold: " << amount << " | ";
    os << "Total Due: " << ret << std::endl;
    return ret;
}
```

我们既能使用基类 `Quote` 的对象来调用这个函数，也能使用派生类 `Bulk_quote` 的对象来调用这个函数；因为该函数是使用引用类型来调用 `net_price` 成员函数的，也就是说： **<u>实际传入 `print_total` 函数的对象类型将决定到底执行基类还是派生类的 `net_price` 成员函数</u>** ：

```C++
// quote 的类型是 Quote，bulk 的类型是 Bulk_quote
print_total(std::cout, quote, 20); // Quote::net_price
print_total(std::cout, bulk, 20); // Bulk_quote::net_price
```

因为上述过程中，函数的运行版本由实参的类型决定，即在运行时选择函数的版本，所以 **<u>动态绑定</u>** 又被称为 **<u>运行时绑定</u>** 。

> 在 C++ 中，使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。

## 15.2 定义基类和派生类

### 15.2.1 定义基类

```C++
class Quote {
public:
    Quote() = default;
    Quote(const std::string& isbn, double sales_price) :
        book_no(isbn), unit_price(sales_price) {  }
    std::string isbn() const { return book_no; }
    // 返回给定数量的书籍的销售总额
    // 派生类负责改写并使用不同的折扣计算算法
    virtual double net_price(std::size_t amount) const { return amount * unit_price; }
    virtual ~Quote(); // 对析构函数进行动态绑定
private:
    std::string book_no; // 书籍 ISBN 编号
protected:
    double unit_price = 0.00; // 代表普通状态下不打折的价格
};
```

> 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

#### 成员函数与继承

派生类需要对虚操作提供自己的新定义以 **<u>覆盖（ `override` ）</u>** 从基类继承来的旧定义。

基类必须将它的两种成员函数区分开来：

* 基类希望其派生类进行覆盖的函数（ 基类使用 **虚函数** ）；
* 基类希望派生类直接继承而不改变的函数。

当我们使用指针或者引用调用虚函数时，该调用也将被动态绑定。根据指针或者引用类型的不同，该调用可能执行基类或者派生类的版本。

基类通过在其成员函数的声明语句之前加上关键字 `virtual` 使得该函数执行动态绑定。虚函数的核心特征：

* 任何 **<u>构造函数之外</u>** 的 **<u>非静态函数</u>** 都可以是虚函数。
* **<u>关键字 `virtual` 只能出现在类内部的声明语句之前</u>** 而不能用于类外部的函数定义。
* **如果基类将一个函数声明为虚函数，那么该函数在派生类中隐式的也是虚函数** 。

成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。

#### 访问控制与继承

派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承来的成员。 **基类的私有成员不能被派生类直接访问** 。

### 15.2.2 定义派生类

派生类必须通过使用 **<u>类派生列表</u>** 明确指出它是从哪个（些）基类继承而来的。**<u>首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个： `public` ， `protected` 或者 `private`</u>** 。

派生类必须将其继承来的成员函数中 **需要覆盖的那些重新声明** 。因此，我们的 `Bulk_quote` 类必须包含一个 `net_price` 成员：

```C++
class Bulk_quote : public Quote {
public:
    Bulk_quote() = default;
    Bulk_quote(const std::string&, std::size_t, double);
    double net_price(std::size_t) const override;
private:
    std::size_t min_qty = 0; // 适用折扣的最低购买量
    double discount = 0.0; // 小数表示的折扣
};
```

派生类列表中的「访问说明符」的作用是：**<u>控制派生类从基类继承而来的成员是否对派生类的用户可见</u>** 。如果是公有继承，则基类的公有成员也是派生类接口的组成部分。此外， **<u>可以将公有派生类型的对象绑定到基类的引用或者指针上</u>** 。

大多数类都只派生自一个类，这种形式的继承被称为「单继承」。

#### 派生类中的虚函数

**如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他普通成员，派生类会直接继承其在基类中的版本** 。

#### 派生类对象及派生类向基类的类型转换

派生类对象包含多个组成部分：

* **<u>含有派生类自己定义的（非静态）成员的「子对象」</u>** 。
* **<u>与该派生类继承的「基类对应的子对象」，如果有基类，那么这样的「子对象」也有多个</u>** 。

**<u>也就是说，派生类对象其实是个缝合怪，它不是一个普通的对象，而是由几个子对象组成的一个复合对象</u>** 。 C++ 对象没有明确规定派生类的对象在内存中如何分布。

因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类的对象使用，而且我们也能将基类的指针或者引用绑定到派生类对象的基类子对象上：

```C++
Quote item; // 基类对象
Bulk_quote bulk_item; // 派生类对象
Quote* p = &item; // p 指向基类对象
p = &bulk_item; // p 指向派生类对象中的基类子对象
Quote& r = bulk_item; // r 绑定到 bulk_item 对象中的 Quote 子对象上
```

这种转换通常称为 **派生类到基类的类型转换** 。编译器会隐式的执行派生类到基类的转换。这个特点意味着，我们可以将派生类的对象用在基类引用或者指针的地方。

> **在派生类对象中含有一个基类的子对象，这一事实是继承的关键所在** 。

#### 派生类构造函数

派生类构造函数无法直接初始化继承而来的成员。 **<u>派生类必须使用基类的构造函数来初始化它的基类子对象</u>** 。

> **每个类控制它自己的成员初始化过程** 。

派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。

```C++
class Quote;
class Bulk_quote : public Quote {
public:
    Bulk_quote(
        const std::string& bn, double up,
        std::size_t qty, double disc
        // 必须使用 Quote 来构造从基类继承而来的成员
        // 而不是直接像自有成员那样直接进行构造
    ) : Quote(bn, up), min_qty(qty), discount(disc) {  }
    ...
};
```

可以看出，要构造 `Bulk_quote` 对象，首先要将前两个参数传递给 `Quote` 构造函数，在 `Quote` 构造函数 **<u>函数体</u>** 结束之后，我们构建的 `Bulk_quote` 基类部分也就构造完成了。接下来初始化列表会初始化由派生类直接定义的 `min_qty` 成员和 `discount` 成员，最后运行 `Bulk_quote` 构造函数的（空的）函数体。

> 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。

#### 派生类使用基类的成员

派生类可以访问基类的公有成员和受保护成员：

```C++
// 如果达到了购买书籍的某个最低限量值，就可以享受折扣
double Bulk_quote::net_price(std::size_t amount) const
{
    if (amout >= min_quantity) {
        return amount * price * (1 - discount);
    } else {
        return amount * price;
    }
}
```

**<u>派生类的作用域嵌套在基类的作用域之内</u>** 。因此，对于派生类的一个成员来说，它使用派生类成员的方式和使用基类成员的方式没有不同。

#### 关键概念：遵循基类的接口

每个类负责定义各自的接口。**<u>要想与类的对象交互，必须使用该类的接口，即使这个对象是派生类的基类部分也是如此</u>** 。因此，派生类对象不能直接初始化基类的成员。尽管在派生类构造函数体内给其继承来的公有或者受保护的基类成员赋值（强烈建议不这样做）。 **<u>派生类应当遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类继承而来的成员</u>** 。

#### 继承与静态成员

如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出多少个派生类，对于每个静态成员来说都只存在 **<u>唯一的实例</u>** 。

静态成员遵循通用的访问规则，如果基类的中的成员是 `private` 的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它，也能通过派生类使用它。

```C++
class Base {
public:
    static void statmem();
};

class Derived : public Base {
    void func(const Derived& de);
};

void Derived::func(const Derived& de) {
    Base::statmem(); // 正确：Base 定义了 statmem
    Derived::statmem(); // 正确：Derived 可以访问继承来的 statmem
    // 正确：派生类的对象能访问基类的静态成员
    de.statmem(); // 通过 Derived 对象进行访问
    statmem();    // 通过 this 对象进行访问
}
```

#### 派生类的声明

派生类的声明中包含类名，**<u>但是不包含类派生列表</u>** ：

```C++
class Bulk_quote : public Quote; // 错误：派生列表不能出现在声明中
class Bulk_quote; // 正确：类声明的正确方式！
```

一条声明语句的目的是 **<u>令程序知晓某个名字的存在以及该名字表示一个什么样的实体，例如一个类、一个变量或者一个函数</u>** 。类派生列表现在不需要出现在这里（类派生列表属于定义的范畴）。

#### 被用作基类的类

**<u>如果一个类要被用作基类，则该类必须已经定义</u>** ！

* 派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类需要知道这些成员是什么。
* 一个类不能派生其本身。

一个类可以是基类的同时也是派生类：

```C++
class Base { ... };
class D1 : public Base { ... };
class D2 : D1 { ... };
```

`Base` 是 `D1` 的 **直接基类** ，同时是 `D2` 的 **间接基类** 。直接基类出现在类派生列表中，而间接基类由派生类通过其直接基类派生而来。 **<u>每个类都会继承直接基类的所有成员</u>** 。并且以此进行递归。因此，**最终的派生类将包含它的直接基类的子对象，以及每个间接基类的子对象** 。

#### 防止继承的发生

如果不希望一个类被继承，那么就在类名之后跟一个关键字： `final` ：

```C++
class NoDerived final { ... }; // NoDerived 不能作为基类
class Base { ... };
// Last 是 final 的，不能继承 Last
class Last final : Base { ... }; // Last 不能作为基类
class Bad : NoDerived { ... }; // 错误：NoDerived 是 final 的
class Bad2 : Last { ... };     // 错误：Last 是 final 的
```

### 15.2.3 类型转换与继承

**<u>理解基类和派生类之间的类型转换是理解 C++ 语言面向对象编程的关键</u>** 。

**<u>我们可以将基类的指针或者引用绑定到派生类的对象上</u>** 。而这一特性具有一个非常重要的含义： **<u>当使用基类的引用或者指针时，实际上我们并不清楚该引用或者指针绑定的真实类型，绑定的对象可能是个基类的对象，也可能是派生类对象</u>** 。

> 和内置指针一样，智能指针类也支持派生类向基类的内行转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。

#### 静态类型与动态类型

当使用存在继承关系的类型时，必须将一个变量或者其他表达式的 **静态类型** 与 该表达式表示对象的 **动态类型** 区分开来。

* **<u>表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型</u>** 。
* **<u>动态类型则是变量或者表达式表示的内存中的对象的类型</u>** 。动态类型直到运行时才可知。

比方说：

```C++
double ret = item.net_price(amount);
```

这里 `item` 的静态类型是 `Quote&` ，它的动态类型则依赖于 `item` 绑定的实参（可能会绑定 `Quote` 对象，也可能会绑定 `Bulk_quote` 对象），这个动态类型直到运行时调用该函数时才会知道。举例来说，如果我们将一个 `Bulk_quote` 对象传递给函数 `print_total( ... const Quote& item, ...)` ，那么 `item` 的静态类型是 `Quote` ，而动态类型是 `Bulk_quote` 。

**<u>如果表达式既不是引用，也不是指针，则它的动态类型永远与静态类型一致</u>** 。

> **<u>基类的指针或者引用的静态类型可能与其动态类型不一致</u>** 。

#### 不存在从基类向派生类的隐式类型转换……

之所以存在派生类向基类的类型转换是因为： **<u>每个派生类对象都包含一个基类部分，而基类的引用或者指针可以绑定到该基类部分上</u>** 。一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在。即， **基类对象是派生类对象的一部分** 。

因为派生类对象不是基类对象的一部分，所以派生类的引用或者指针不能绑定在基类对象上，因为派生类的引用或者指针会发现缺少了很多东西。

即使一个基类指针或者引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换。

#### ……在对象之间不存在类型转换

派生类向基类的自动转换只针对「引用类型」或者「指针类型」， **在派生类类型和基类类型之间并不存在这样的转换** 。也就是说，一个派生类对象不可能彻底转换成一个基类对象，只是基类指针和基类引用能绑定在其对象的基类部分而已。

**<u>当我们初始化或者赋值一个类类型的对象时，实际上是在调用某个函数</u>** 。当执行初始化时，我们调用构造函数；而执行赋值操作时，我们调用赋值运算符。这些成员通常都包含一个参数，类型是该类类型的 `const` 版本的引用。

当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个，显然该构造函数智能处理基类自己的成员。类似的，如果我们将一个派生类对象赋值给一个基类对象，则实际运行的赋值运算符也是基类中定义的那个，该运算符智能处理基类自己的成员。

```C++
Bulk_quote bulk; // 派生类对象
Quote item(bulk); // 使用 Quote::Quote(const Quote&) 构造函数
item = bulk; // 使用 Quote& Quote::operator = (const Quote&)
```

在上述操作中， `Quote` 的构造函数会忽略掉 `Bulk_quote` 的自有部分，所以我们可以说 `bulk` 的 `Bulk_quote` 部分被 **「切掉」** 了。

> **<u>当我们用一个派生类对象为一个基类对象初始化或者赋值时，只有该派生类对象中的基类子对象会被拷贝、移动或者赋值，它的派生类部分将会被忽略掉</u>** 。

#### 关键概念：存在继承关系的类型之间的转换规则

* 从派生类向基类的类型转换只对「指针」或者「引用」类型有效。
* 基类向派生类不存在隐式类型转换。
* 派生类向基类的类型转换也可能会由于访问受限而变的不可行。

通常能够将一个派生类对象拷贝、移动或者赋值给一个基类对象。不过需要注意的是，这种操作只处理派生类对象的基类部分。