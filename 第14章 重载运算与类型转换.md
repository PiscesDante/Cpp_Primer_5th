# 第14章 重载运算与类型转换

## 14.1 基本概念

重载的运算符是具有特殊名字的函数： **<u>它们的名字由关键字 `operator` 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体</u>** 。

「重载运算符函数」的参数数量与该运算符作用的运算对象数量一样多。除了重载的函数调用运算符 `operator ()` 之外，其他的重载运算符不能含有默认实参。

如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的 `this` 指针上。 **因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个** 。

```C++
// 错误：不能为 int 重定义内置的运算符
int operator + (int lhs, int rhs);
```

**我们只能重载已有的运算符，而无权发明新的运算符号** 。

#### 直接调用一个重载的运算符函数

```C++
// 一个非成员运算符函数的等价调用
data1 + data2;             // 普通的表达式
operator + (data1, data2); // 等价的函数调用
```

以上两个形式的调用是等价的。

```C++
data1 += data2;            // 基于「调用」的表达式
data1.operator += (data2); // 对成员运算符函数的等价调用
```

#### 某些运算符不应该被重载

因为有些运算符，特别是 **逻辑于运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则无法保留下来** 。因此，不建议重载它们。比方说重载的 `&&` 可能会没有短路求值的操作。

**<u>同样地，我们也不重载逗号运算符和取地址运算符</u>** 。

> 通常情况下，不应当重载逗号、取地址、逻辑与和逻辑或运算符。

#### 使用与内置类型一致的含义

* 如果类执行输入输出操作，则定义位移运算符使其与内置类型输入输出保持一致。
* 如果检查相等性的操作，则定义 `operator == ` ；如果类有了 `operator == ` ，意味着它通常也应当有 `operator !=` 。
* 如果一个类包含一个内在的单序比较操作，则定义 `operator < ` ；如果类有了 `operator < ` ，则它也应该有其他关系的操作符。
* 重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容。

#### 提示：尽量明智的使用运算符重载

* 把二元运算符映射到类类型的一个类似操作上可以极大的简化记忆。
* 当在内置的运算符和我们自己的操作之间存在逻辑映射关系时，运算符重载的效果最好。
* 只有当操作的含义对于用户来说清晰明了时才使用运算符。如果用户对运算符可能有几种不同的理解，则使用这样的运算符将产生二义性。

#### 赋值和复合赋值运算符

赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧运算对象的一个引用。重载的赋值运算符应当 **继承** 而非违背其内置版本的含义。

#### 选择作为成员或者非成员

* 赋值（ `=` ），下标（ `[]` ），调用（ `()` ）和成员访问箭头（ `->` ）运算符必须是成员。
* 复合赋值运算符一般来说是成员函数，但非必须。
* **改变对象状态的运算符或者与给定类型密切相关的运算符，通常应当是成员** 。
* 具有对称性的运算符可能转换任意一端的的运算对象，因此通常应当是非成员函数。

**当我们把运算符定义成成员函数时，它的<u>左侧运算对象</u>必须是运算符所属类的一个对象** 。

```C++
std::string s = "World";
std::string t = s + "!"; // 正确：我们能把一个 const char* 加到一个 std::string 对象中
std::string u = "hi" + s; // 如果 + 是 std::string 的成员函数，则产生错误
```

## 14.2 输入和输出运算符

### 14.2.1 重载输出运算符 `<<`

第一个形参是一个非常量 `ostream` 对象的引用，因为这个流的状态需要被改变；第二个形参是一个常量的引用，该常量不涉及内容的修改，它只负责像流输出数据。为了与其他输出运算符保持一致， `operator <<` 一般要返回它的 `ostream` 形参。

#### `Sales_data` 的输出运算符

```C++
std::ostream& operator << (std::ostream& os, const Sales_data& rhs)
{
    os << rhs.book_no << " ";
    os << rhs.units_sold << " ";
    os << rhs.revenue << " ";
    os << rhs.avg_price();
    return os;
}

// Using:
Sales_data item;
std::cout << item << std::endl;
```

#### 输出运算符尽量减少格式化操作

**通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符** 。

#### 输入输出运算符必须是非成员函数

```C++
Sales_data item;
item << std::cout; // 如果 operator << 是 Sales_data 的成员函数
```

如果我们希望为类自定义输入输出运算符，则必须将其定义成非成员函数。**当然，因为输入输出经常需要读写类的私有成员，故一般被声明为友元** 。

### 14.2.2 重载输入运算符 `>>`

#### `Sales_data` 的输入运算符

```C++
std::istream& operator >> (std::istream& is, Sales_data& rhs)
{
    // 不需要初始化，因为我们将先读入数据到 price ，之后才使用它
    double price;
    is >> rhs.book_no >> rhs.units_sold >> price;
    if (is) {
        rhs.revenue = rhs.units_sold * price;
    } else {
        rhs.Sales_data(); // 输入失败：对象被赋予默认状态
    }
    return is;
}
```

> 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。

#### 输入时的错误

当读取操作发生错误时，输入运算符应该负责从错误中恢复。

#### 标示错误

最好的方式是由输入输出标准库自己来标示这些错误。

## 14.3 算术和关系运算符

算数运算符通常会计算它的两个运算对象并且得到一个新值，这个值有别鱼任意一个运算对象，常常位于一个局部变量之内，操作完成后返回该局部变量的副本作为其结果。所以，最有效的方式是 **使用复合赋值来定义算数运算符** 。

```C++
// 假设两个对象指向同一本书
Sales_data
operator + (const Sales_data& lhs, const Sales_data& rhs)
{
    Sales_data ret = lhs;
    ret += rhs;
    return ret;
}
```

> 如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应当使用复合赋值运算符来实现算数运算符。

### 14.3.1 相等运算符

```C++
bool operator == (const Sales_data& lhs, const Sales_data& lhs)
{
    return lhs.book_no == rhs.book_no &&
           lhs.units_sold == rhs.units_sold &&
           lhs.revenue == rhs.revenue;
}

bool operator != (const Sales_data& lhs, const Sales_data& lhs)
{
    return !(lhs == rhs);
}
```

#### 设计准则

* 如果要定义相等性的判断， **则它显然应该把函数定义成 `operator ==` 而非一个普通的命名函数** 。
* 如果类定义了 `operator ==` ，则该运算符应该能判断一组给定的对象中是否含有重复数据。
* `operator ==` 应当具有传递性。
* 如果类定义了 `operator ==` ，则也应当定义 `operator !=` ，反之亦然。
* 相等和不等运算符中的一个应当把工作委托给另外一个。

### 14.3.2 关系运算符

关联容器和一些算法要用到小于运算符，所以定义 `operator <` 会比较有用。

通常情况下关系运算符应当：

1. 定义顺序关系，令其与关联容器中对关键字的要求一致。
2. 如果类同时也含有 `==` 运算符的话，则定义一种关系令其与 `==` 保持一致。特别是，如果两个对象是 `!=` 的，那么一个对象应该 `<` 另一个。

> 如果存在唯一一种逻辑可靠的 `<` 定义，则应该考虑为这个类定义 `<` 运算符。如果类同时还包含 `==` ，则当且仅当 `<` 的定义和 `==` 产生的结果一致时才定义 `<` 运算符。

## 14.4 赋值运算符

```C++
std::vector<std::string> v;
v = { "a", "an", "the" };
```

```C++
class StrVec {
public:
    StrVec& operator = (std::initializer_list<std::string> rhs);
    ...
};

StrVec& StrVec::operator = (std::initializer_list<std::string> rhs)
{
    // 无需检查自赋值问题
    auto data = alloc_n_copy(rhs.begin(), rhs.end());
    free();
    elements = data.first;
    first_free = cap = data.second;
    return *this;
}
```

> 我们可以重载赋值运算符。 **无论形参的类型是什么，赋值运算符都必须定义为成员函数** 。

#### 复合赋值运算符

复合赋值运算符不一定非得是类的成员，不过我们还是倾向于把所有赋值运算符定义在类的内部。

```C++
Sales_data& Sales_data::operator += (const Sales_data& rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}
```

> 赋值运算符必须定义成累得成员，复合赋值运算符通常情况下也该这样做。这两类运算符都应该返回左侧运算对象的引用。

## 14.5 下标运算符

> 下标运算符必须是成员函数。

下标运算符通常以所访问元素的引用作为返回值，这样的好处是下标可以出现在赋值运算符的任何一端。

我们最好同时定义下标运算符的常量版本和非常量版本，当作用与一个常量对象时，下标运算符返回的引用就会确保对象的值不会被更改。

> 两个版本：一个返回普通引用，一个是类的常量成员并且返回常量引用。

```C++
class StrVec {
public:
    std::string& operator [] (std::size_t rank) {
        return elements[rank];
    }

    // 常量引用 + 常量成员函数
    const std::string& operator [] (std::size_t rank) const {
        return elements[rank];
    }
};
```

## 14.6 递增和递减运算符

C++ 语言并不要求递增和递减运算符必须是类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。

> 定义递增和递减运算符的类应该同时定义前置和后置的版本。这些运算符通常应该被定义成类的成员。

#### 定义前置递增/递减运算符

#### 区分前置和后置运算符

普通的重载形式无法区分这两种情况。为了解决这个问题，**<u>后置版本接受一个额外的（不被使用）的 `int` 类型的形参</u>** 。当我们使用后置运算符时，编译器为这个形参提供一个值为 `0` 的实参。尽管从语法上来说后置函数可以使用这个额外的形参，但是实际使用过程中却不这样做。 **这个形参的「唯一作用就是区分前置和后置版本的函数」，而不是要参与实际的运算** 。 **<u>这个参数列表中的 `int` 更像是 `后置` 的同义词</u>** 。

> 为了与内置版本保持一致，后置运算符应该返回对象的原值（变动之前的值），返回的形式是一个值而非引用。

> 因为不会用到 `int` 形参，所以无需为其命名。

#### 显式的调用后置运算符

可以显式的嗲偶用一个重载的运算符，其效果是完全一样的。如果我们想通过函数调用的方式调用后置版本，则必须为它的整形参数传递一个值：

```C++
StrBlobPtr p(a1); // p 指向 a1 中的 vector
p.operator++(0); // 后置，这个值必须被传入，编译器就靠这个「无用」的值分辨前置和后置
p.operator++();  // 前置
```

## 14.7 成员访问运算符

