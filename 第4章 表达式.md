# 第4章 表达式

表达式由一个或者多个 **运算对象** 组成，对表达式求值将得到一个 **结果** 。字面值和变量是最简单的表达式，其结果就是字面值或者变量本身的值。把一个 **运算符** 和 若干个 **运算对象** 组合起来可以生成较为复杂的表达式。

## 4.1 基础

### 4.1.1 基本概念

函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。

#### 组合运算符和运算对象

#### 运算对象转换

小整数类型通常会被 **提升** 成为较大的整数类型。

#### 重载运算符

**当运算符作用于类类型的运算符对象时，用户可以自定义其含义** 。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以称之为 **重载运算符** 。然而，运算对象的个数、优先级和结合律都是无法改变的。

#### 左值和右值

一个左值表达式的求值结果是 **一个对象** 或者 **一个函数** ，然而一常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。

**当一个对象被用作右值的时候，用的对象的值（内容）；当一个对象被用作左值的时候，使用的是对象本身（在内存中的存储空间）** 。

需要右值的地方可以使用左值来代替，但是不能把右值当成左值（也就是内存空间）来使用。当一个左值被当成右值来使用的时候，本质上是在使用左值内存上的数据。

* **内置解引用运算符** 、 **下标运算符** 、 **迭代器解引用运算符** 、 **`string` 和 `vector` 的下标运算符** 的求值结果都是 **左值** 。
* **前置版本的递增和递减运算符** 得到的结果就是 **左值** 。
* 对关键字 `decltype` 使用 **左值** 的时候，得到的是一个引用类型。

### 4.1.2 优先级和结合律

**复合表达式** 是指 **含有两个或者多个运算符的表达式** 。优先级和结合律决定了对象的组合方式。当然也可以使用括号来人为规定结合律以及优先级。表达式最终的值依赖于其子表达式的组合方式。

#### 括号无视优先级和结合律

#### 优先级与结合律有何影响

```C++
int arr[] { 2,4,6,8 };
int last = *(arr + 2); // last = arr[2] == 6
last = *arr + 2; // last = arr[0] + 2 == 4
```

### 4.1.3 求值顺序

优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值顺序。

4 种明确规定了运算对象求值顺序：

* `&&`（逻辑与）。
* `||`（逻辑或）。
* `?:`（条件运算符）。
* `,`（逗号运算符）。

#### 求值顺序、优先级、结合律

运算对象的求值顺序与结合律以及优先级无关。

#### 处理符合表达式

* 拿不准的时候最好使用括号来强制让表达式的组合关系符合程序逻辑的要求。
* 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。

## 4.2 算术运算符

所有算术运算符都满足 **左结合律** 。意味着 **当优先级相同时，按照从左到右的顺序进行组合** 。

算术运算符的运算对象和求值结果都是右值。

当一元正号运算符作用于一个指针或者算数值是，返回运算对象值的一个（提升后的）副本：

```C++
int i = 10;
int k = -i; // k = -10
bool b = true;
bool b2 = -b; // b2 = true
```

`b` 被提升称为 `int` ，对其求负之后为 `-1` ，显然这个值不是 `0` 于是 `b2` 的值是真。

整数除法的结果还是整数， **如果商有小数部分，直接丢弃** 。

参与取余运算的运算对象必须是整数。

C++11 新标准规定，整数除法的商一律 **向 `0` 取整** 。也就是直接丢弃小数部分。

根据取余运算的定义：

* `(-m) / n == -(m / n)`
* `m / (-n) == -(m / n)`
* `m % (-n) == m % n`
* `(-m) % n == -(m % n)`

## 4.3 逻辑和关系运算符

关系运算符作用于 **算术类型** 或者 **指针类型** 。逻辑运算符作用于 **任意能转换成为布尔值的类型** 。以上两者返回值都是布尔类型。运算对象和求值结果都是 **右值** 。

#### 逻辑与和逻辑或运算符

这两个运算符都有 **短路求值** 的特点：**<u>当左侧的运算符能确定整个表达式的返回值时，右侧的表达式将不再参与运算</u>** 。

#### 逻辑非运算符

逻辑非运算符（ `!` ）将运算对象的值取反后返回。

#### 关系运算符

关系运算符满足 **左结合律** 。

#### 相等性测试与布尔字面值

```C++
if (val) { ... } // 如果 val 非 0，条件为真
if (!val) { ... } // 如果 val 是 0，条件为真

if (val == true) { ... } 
// 只有当 val == 1 时条件才为真，一定注意这里的区别
// 而且如果 val 不是布尔值，这样的比较就没有意义
```

**进行比较运算时， 除非比较的对象是布尔类型，否则不要使用布尔字面值 `true` 和 `false` 作为运算对象** 。

## 4.4 赋值运算符

赋值运算符的左侧运算对象必须是一个可以修改的 **左值** 。如果赋值运算符的左右两个运算对象类型不同，则右侧的运算对象将转换成左侧对象的类型。

C++11 允许使用初始值列表作为右侧运算对象，如果左侧的对象是内置类型，那么初始值列表中最多只能包含一个值，而且该值即使转换，其所占空间也不应大于目标类型的空间。

无论左侧运算对象是什么，初始值列表都可以为空。

#### 赋值运算满足右结合律

#### 赋值运算符优先级较低

```C++
// 这是一种繁琐且容易出错的写法
int i = get_value(); // 得到第一个值
while (i != 42) {
    ...
    i = get_value(); // 得到剩下的值
}
```

修改后的形式：

```C++
int x;
while ((x = get_value()) != 42) { ... }
```

**因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应当加上括号** 。

#### 切勿混淆相等运算符和赋值运算符

#### 复合赋值运算符

任意一种符合运算符都完全等价于

```C++
a = a operator b;
```

唯一的区别是 **左侧运算对象的求值次数** ：使用复合运算符只求值一次，使用普通的运算符则求值两次。两次分别是：

* 作为右边子表达式的一部分求值。
* 作为赋值运算的左侧运算对象求值。

## 4.5 递增和递减运算符

很多迭代器本身不支持算数运算，所以这两个运算符除了书写简洁之外还是必须的。

* 前置版本：首先改变运算对象，然后将改变后的对象作为结果返回。
* 后置版本：先返回运算对象改变前的副本，再改变运算对象本身。

前置版本将 **对象本身作为左值返回** ，后置版本 **返回运算对象原始值的副本，这个副本本质上是一个右值** 。

> **除非必须，否则不用递变运算符的后置版本** 。

#### 在一条语句中混用解引用和递增运算符

**后置递变运算符** 的优先级 **高于** 解引用符，所以是先对指针进行递变操作，也就是先返回指针的副本，然后对指针本身进行递变。这时解引用运算符就会作用在返回的副本上。

#### 运算对象可以按任意顺序求值

## 4.6 成员访问运算符

**点运算符** 和 **箭头运算符** 都可以用来访问成员。

```C++
std::string s = "STRING";
std::string* sp = &s;
auto l = s.size(); // 访问 string 对象 s 的 size 成员
l = (*sp).size(); // 访问 sp 所指对象的 size 成员
l = sp->size(); // 同上
```

因为 **解引用运算符** 的优先级 **低于** 点运算符，所以必须加上括号。

## 4.7 条件运算符

条件运算符（ `?:` ）允许我们将 `if - else` 逻辑嵌入到单个的表达式中。

```C++
condition ? expression1 : expression2;
```

条件运算符的执行过程是：**<u>首先求 `condition` 的值，如果条件为真对 `expression1` 求值并且返回该值，否则对 `expression2` 求值并且返回该值</u>** 。

#### 嵌套条件运算符

随着条件运算嵌套层数的增加，代码的可读性会急剧下降。因此嵌套最好不要超过两层。

#### 在输出表达式中使用条件运算符

条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算符子表达式时，通常需要在它的两端加上括号：

```C++
std::cout << ((grade < 60) ? "FAIL" : "PASS");
// 输出 PASS 或者 FAIL

std::cout << (grade < 60) ? "FAIL" : "PASS";
// 输出 1 或者 0，等价于：
std::cout << (grade < 60);
std::cout ? "FAIL" : "PASS";

std::cout << grade < 60 ? "FAIL" : "PASS"; 
// 错误：试图比较 std::cout 和 60，等价于：
std::cout << grade; // 输出 grade
std::cout < 60 ? "FAIL" : "PASS"; // 比较 std::cout 和 60！
```

## 4.8 位运算符

位运算符作用于 **整数类型** 的运算对象，并把运算对象看成是二进制位的集合。

关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算用于处理无符号类型。

#### 位移运算符

首先令左侧运算对象的内容按照右侧运算对象执行基于二进制位的移动指定的位数，然后将经过移动甚至提升了的左侧运算对象的拷贝作为求值结果。其中右侧的运算对象一定不能为负，而且严格小于结果的位数，否则会产生为定义的行为。

二进制位的左移和右移，移出边界之外的值就被舍弃掉了。

左移运算符（ `<<` ）在右侧插入值为 `0` 的二进制位。右移运算符（ `>>` ）的行为则依赖于其左侧运算对象的类型：

* **无符号类型** ：在左侧插入值为 `0` 的二进制位。
* **带符号类型** ：在左侧插入 **符号位的副本** 或者值为 `0` 的二进制位。

#### 位求反运算符

#### 位与、位或、位异或运算符

#### 使用位运算符

#### 位移运算符（又叫 IO 运算符）满足左结合律

因为位移运算满足左结合律，所以表达式：

```C++
std::cout << "Hello" << "World" << std::endl;
```

等价于：

```C++
(((std::cout << "Hello") << "World") << std::endl;)
```

位移运算符的优先级比算术运算符要低，但是比关系，赋值，条件运算符的优先级要高。所以在必要的场合最好添加括号以便手动指定执行顺序。

## 4.9 `sizeof` 运算符

**`sizeof` 运算符** 返回一条表达式或者一个类型名字 **所占的字节数** 。该运算符满足 **右结合率** ，返回的类型是 `const size_t`（一个常量类型） 。运算符的运算对象有两种形式：

```C++
sizeof (type); // 返回类型本身大小
sizeof expression; // 返回表达式返回值类型大小
```

其实这里建议无论是对类型还是表达式本身，都可以加上括号，以防止优先级出现问题。

`sizeof` 运算符本身并不对运算对象求值，所以即使指针是个空指针，也可以求得结果：

```C++
sizeof (p); // 指针本身所占的字节数
sizeof (*p); // 指针所指的对象的字节数

Person* p = new Person(); // 有成员变量 m_name;
sizeof (p->m_name); // m_name 所占的字节数目
sizeof (Person::m_name); // 同上
```

* 对 `char` 或者其类型的变量执行结果为 `1` 。
* 对引用类型执行，得到的事被引用对象所占的空间大小。
* 对指针执行，得到的是指针的大小。
* 对节引用指针执行，得到的是所指类型的大小，指针不需要有效。
* 对数组执行得到的是整个数组所占空间的大小，这里 `sizeof` 并不会将数组名转换成指针处理。

数组的长度可以使用 `sizeof (arr) / sizeof (*arr)` 来计算。

## 4.10 逗号运算符

逗号运算符含有两个运算对象，按照 **从左到右** 的顺序依次求值。首先对左侧的运算符求值，然后将求值结果丢弃掉。逗号运算符真正的结果是 **右侧的表达式的值** 。如果右侧运算对象是左值，那么最终的求值结果也是左值。

## 4.11 类型转换

两种类型可以互相转换，那么它们就是关联的。

C++ 语言不会直接将两个不同类型的值相加，而是先根据类型转换规则设法将运算对象的类型统一之后再求值。无需程序员介入的转换被称为 **隐式转换** 。

#### 何时发生隐式类型转换

* 再大多数表达式中，比 `int` 类型小的整型值首先提升为较大的整数类型。
* 在条件中，非布尔值转换成布尔类型。
* 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
* 运算过程中需要统一类型。
* 函数调用时也会发生类型转换。

### 4.11.1 算术转换

算术转换中，运算符的运算对象将转换成为 **最宽** 的类型。当表达式中既有浮点类型也有整数类型时，整数值将转换成相应的浮点类型。

#### 整型提升

负责将小整数类型转换成较大的整数类型。

#### 无符号类型的运算对象

首先执行整型提升。如果结果的类型匹配，无须进行进一步的转换。如果两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型转换成大类型。

如果一个运算对象是无符号类型、另一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。

### 4.11.2 其他隐式类型转换

* **数组转换成指针** ：数组自动转换成指向数组首元素的指针。然而当数组被用作 `decltype` 关键字的参数，或者作为取地址符、`sizeof` 以及 `typeid` 等运算符的运算对象时，上述转换不会发生。
* **指针的转换** ：`0` 或者 `nullptr` 能转换成任意类型的指针。指向任意非常量的指针能转换成 `void*` 。指向常量的指针会转换成为 `const void*` 。
* **转换成为布尔类型** ：如果指针或者算术类型的值为 `0`，转换结果是 `false` ；否则结果是 `true` 。
* **转换成常量** ：允许将指向非常量类型的指针转换成指向相应的常量类型的指针。
* **类类型定义的转换** 。

### 4.11.3 显式转换

虽然有时候必须使用 **强制类型转换（ cast ）** ，但是这种方法本质上是十分危险的。

#### 命名的强制类型转换

```C++
cast_name<target_type>(expression);
```

如果 `target_type` 是引用类型，那么得到的是左值。其中 `cast_name` 有：

```C++
static_cast<type_name>(expression);
dynamic_cast<type_name>(expression);
const_cast<type_name>(expression);
reinterpret_cast<type_name>(expression);
```

#### `static_cast`

任何具有明确定义的类型转换，只要不包含底层 `const` ，都可以使用 `static_cast` 。当需要将一个较大的算术类型赋值给较小的类型时，该方法可以忽略精度损失所产生的警告。

#### `const_cast`

**`const_cast` 只能改变运算对象的底层 `const`** ：

```C++
const char* pc;
char* p = const_cast<char*>(pc);
// 正确：但是通过 p 写入是为定义的行为
```

如果对象本身不是一个常量，使用强制类型转换获得 写权限 是合法的行为。然而如果对象是一个常量，再使用 `const_cast` 执行写操作就会产生 **未定义行为** 。

#### `reinterpret_cast`

`reinterpret_cast` 通常为运算对象的位模式提供较低层次上的重新解释。这个操作十分不安全，强烈建议不要使用。

#### 避免使用强制类型转换

强制类型转换干扰了正常的类型检查，因此我们强烈建议程序员避免使用强制类型转换。

#### 旧式的强制类型转换

```C++
type(expr); // 函数形式的强制类型转换
(type)expr; // C 语言风格的强制类型转换
```

## 4.12 运算符优先级表