# 第7章 类

类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程技术。

* **类的接口** ：**<u>用户所能执行的操作</u>** 。
* **类的实现** ：类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

**封装** 实现了类的接口和实现的分离。类的用户只能使用接口而无法访问实现部分。

类要想实现 **数据抽象** 和 **数据封装** ，需要首先定义一个抽象数据类型。在抽象数据类型中，由类的设计者负责考虑类的实现细节和过程；使用这个类的程序员只需要知道这个类的对象能完成什么动作和功能就行了，而不需要了解这个类是怎么实现的。

## 7.1 定义抽象数据类型

### 7.1.1 设计 `Sales_data` 类

`Sales_item` 类有一个名为 `isbn` 的成员函数，并且支持各种运算符。

综上所述，`Sales_data` 的 **接口** 应该包含以下的操作：

* 一个 `isbn` 成员函数，用于返回对象的 `ISBN` 编号。
* 一个 `combine` 成员函数，用于将一个 `Sales_data` 对象加到当前对象上。
* 一个名为 `add` 的函数（不是成员函数），执行两个 `Sales_data` 对象的加法。
* 一个 `read` 函数，将数据从 `std::istream` 读入到 `Sales_data` 对象中。
* 一个 `print` 函数，将 `Sales_data` 对象的值输出到 `std::ostream` 。

> 关键概念：**程序员是类的用户，程序员使用类来编写程序，程序的用户可能是书店老板。当然在一些简单的程序中，类的设计者和用户是一个人。当我们设计类时，应该考虑如何才能使得类易于使用；而当我们实用类时，不应该顾及类是怎么样实现的** 。

#### 使用改进的 `Sales_data` 类

### 7.1.2 定义改进的 `Sales_data` 类

改进的 `Sales_data` 类应当如下所示：

```C++
struct Sales_data
{
    // 新成员
    std::string isbn() const { return bookNo; } // 类内定义的函数，该函数是返回一个值
    Sales_data& combine(const Sales_data& rhs);
    double avg_price() const;
    // 旧成员
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

// Sales_data 的非成员函数
Sales_data add(const Sales_data& lhs, const Sales_data& rhs);
std::ostream& print(std::ostream& os, const Sales_data& rhs);
std::istream& read(std::istream& is, const Sales_data& rhs);
```

> **定义** 在类 **内部** 的函数是隐式的 `inline` 函数。

#### 定义成员函数

尽管所有的成员都必须在类的内部进行声明，但是成员函数体可以定义在类内也可以定义在类外。

#### 引入 `this` 指针

**当我们调用某个成员函数时，实际上是在使用该类的某个对象进行调用。于是被调用的成员函数隐式的指向了调用它的对象。成员函数通过一个名为 `this` 的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，就会用请求该函数的对象地址初始化 `this` 指针** 。

在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为 `this` 指向的正是这个对象。任何对类成员的直接访问都被看做是对 `this` 的隐式引用。

任何自定义名为 `this` 的参数或者变量都是非法的。因为 `this` 被设计出来的目的总是指向当前调用函数的对象，所以 `this` 的本质是一个 **常量指针** ，因此禁止改变 `this` 中保存的地址。

#### 引入 `const` 成员函数

参数列表之后的 `const` 关键字是用来 **<u>修改隐式 `this` 指针的类型</u>** 。

默认情况下， `this` 的类型是指向类类型 **<u>顶层 `const` 指针，即不可修改指针本身，但是可以修改指向地址上的内容的指针</u>** 。在默认情况下，我们不能把 `this` 绑定到一个常量对象上。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。即， **如果我们定义了一个常量的对象，就无法调用 `isbn` 这个成员函数了** 。

```C++
#include <iostream>
#include <string>

struct Book
{
    Book(const std::string name) :
        book_name(name) { }
    std::string get_name() { return book_name; }
    // 我们将成员函数写成非 const 版本的
    std::string book_name;
};

int main(int argc, char const *argv[])
{
    const Book b1("Gone with the wind"); // const 对象无法调用非 const 成员函数
    std::cout << b1.get_name() << std::endl;
    return 0;
}

// 于是编译器报错：
// a.cc: In function 'int main(int, const char**)':
// a.cc:15:30: error: passing 'const Book' as 'this' argument discards qualifiers [-fpermissive]
//      std::cout << b1.get_name() << std::endl;
//                               ^
// a.cc:8:17: note:   in call to 'std::__cxx11::string Book::get_name()'
//      std::string get_name() { return book_name; }
//                  ^~~~~~~~
```

**<u>由此可见，参数列表后是否有 `const` 决定哪些对象可以进行调用</u> 。如果添加了 `const` ，则常量对象也可以调用这个方法；如果没有添加 `const` ，则只有非常量的对象可以调用** 。

这样使用的 `const` 的成员函数被称作 **常量成员函数** 。

> **常量对象，以及常量对象的引用或者指针都只能调用常量成员函数** 。

#### 类作用域和成员函数

我们注意到，即使成员变量 `bookNo` 定义在 `isbn` 之后， `isbn` 还是能使用 `bookNo` ；这是因为编译器分两步处理类：**<u>首先编译成员的声明，然后才轮到成员函数体。因此，成员函数体可以随意使用类中的其他成员而无须在意成员出现的顺序</u>** 。

#### 在类的外部定义成员函数

成员函数的声明必须和定义保持一致，也就是说，返回类型、参数列表和函数名都得和类内部的声明保持一致。如果成员被声明为常量成员函数，那么它的定义也必须在参数列表后明确指定 `const` 属性。同时，**类外部定义的成员名字必须包含它所属的类名** ：

```C++
struct Sales_data
{
    // 新成员
    std::string isbn() const { return bookNo; } // 类内定义的函数，该函数是返回一个值
    Sales_data& combine(const Sales_data& rhs);
    double avg_price() const;
    // 旧成员
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

double Sales_data::avg_price() const
{
    if (units_sold != 0) {
        return revenue / units_sold;
    } else {
        return 0;
    }
}
```

类外定义的函数名使用了作用域运算符来说明如下事实：**我们定义了一个名为 `avg_price` 的函数，并且该函数被声明在类 `Sales_data` 的作用域内。一旦编译器看到这个函数名，就能理解剩余的代码是位于类的作用域内的** 。

#### 定义一个返回 `this` 对象的函数

我们可以使用返回 **当前对象的的类型的引用** 来返回当前这个对象（的引用）。

### 7.1.3 定义类相关的非成员函数

我们定义非成员函数的方式和定义其他函数一样，通常把函数的声明和定义分离开来。

> 一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个文件里。

#### 定义 `read` 和 `print` 函数

```C++
std::istream& read(std::istream& is, Sales_data& rhs)
{
    double single_price = 0.00;
    is >> rhs.bookNo >> rhs.units_sold >> single_price;
    rhs.revenue = single_price * rhs.units_sold;
    return is;
}

std::ostream& print(std::ostream& os, const Sales_data& rhs)
{
    os << rhs.isbn() << " ";
    os << rhs.units_sold << " ";
    os << rhs.revenue << " ";
    os << rhs.get_price();
    return os;
}
```

* `read` 和 `print` 分别接受一个各自 `IO` 类型的引用作为其参数，这是因为 `IO` 类属于 **不能被拷贝的类型** ，因为我们只能使用引用来进行传递。并且在函数体内需要修改 `IO` 对象的状态，所以 `IO` 对象不能被设置成 `const` 。
* 一切输出的函数不能进行换行。一般来说，执行输出任务的函数应该尽量减少对格式的控制。

#### 定义 `add` 函数

```C++
Sales_data add(const Sales_data& lhs, const Sales_data& rhs)
{
    Sales_data ret = lhs;
    ret.combine(rhs);
    return ret;
}
```

### 7.1.4 构造函数

**类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数** 。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

构造函数的名字和类名相同。 **构造函数没有返回类型** 。构造函数的 **参数列表** 和 **函数体** 都可能为 **空** 。类可以包含多个构造函数，但是不同的构造函数之间必须在 **参数数量** 或者 **参数类型** 上有所区别。

构造函数不能被声明成 `const` 的，因为取得常量属性是在初始化完毕之后。因此，构造函数在 `const` 对象的构造过程中可以向其写入数据。

#### 合成的默认构造函数

类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做 **默认构造函数** 。默认构造函数无须任何实参。

**编译器创建的构造函数** 又被称为合成默认构造函数，对于大多数类来说，合成的默认构造函数将按照如下规则来初始化数据成员：

* 如果存在类内初始值，用它来初始化成员。
* 否则，默认初始化该成员。

#### 某些类不能依赖于合成的默认构造函数

对于一个普通的类，必须定义它自己的默认构造函数，原因有三：

* 编译器只有在发现类 **<u>不包含任！何！构造函数的时候</u>** 才会生成一个默认的构造函数。即：**<u>如果我们定义了一些其他的构造函数，那么除非我们自己手动再定义一个默认的构造函数，否则类将没有默认的构造函数</u>** ！
* 合成的默认构造函数可能执行错误的操作。定义在块中的内置类型或者符合类型（数组和指针）如果被默认初始化，则值是未定义的。所以如果一个类包含有内置类型或者复合类型的成员时， **则只有当这些成员全都被赋予了类内初始值时，这个类才适合于使用合成的默认构造函数** 。所以从这个角度来看，类内初始值有助于消除未定义行为。
* 编译器有时候不能为某些类合成默认的构造函数。

#### 定义 `Sales_data` 的构造函数

```C++
struct Sales_data {
    // 新增的构造函数：
    Sales_data() = default;
    Sales_data(const std::string& s) :
        bookNo(s) { }
    Sales_data(const std::string& s, unsigned n, double p) :
        bookNo(s), units_sold(n), revenue(n * p) { }
    Sales_data(std::istream& is);
    // ...
};
```

#### `= default` 的含义

我们来解释第 4 行的程序。首先明确一点：**因为该函数不接受任何实参，所以它是一个默认构造函数** 。

在 C++11 新标准中， **如果我们需要默认的行为，那么可以通过在参数列表后面写上 `= default` 来主动要求编译器生成构造函数** 。 `= default` 既可以出现在类的内部，也可以出现在类的外部。

#### 构造函数初始值列表

```C++
Sales_data(const std::string& s) :
        bookNo(s) { } // 构造函数初始值列表
Sales_data(const std::string& s, unsigned n, double p) :
        bookNo(s), units_sold(n), revenue(n * p) /* 构造函数初始值列表 */ { }
```

我们把新出现的部分称为 **构造函数初始值列表，它负责为新创建的对象的一个或者几个数据成员赋初始值** 。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的成员初始值。不同成员初始化通过逗号分隔开来。

当某个数据成员被构造函数初始值列表忽略时，它将被默认初始化。

> **构造函数不应该轻易覆盖掉类内的初始值，除非新的值与类内初始值不同** 。如果不能使用类内初始值，则所有构造函数都应该显式的初始化每个内置类型成员。

#### 在类的外部定义构造函数

```C++
struct Sales_data {
    // 新增的构造函数：
    Sales_data() = default;
    Sales_data(const std::string& s) :
        bookNo(s) { }
    Sales_data(const std::string& s, unsigned n, double p) :
        bookNo(s), units_sold(n), revenue(n * p) { }
    Sales_data(std::istream& is);
    // ...
};

Sales_data::Sales_data(std::istream& is) // 这里没有初始值列表
{
    read(is, *this);
}
```

这里一定要注意构造函数没有返回类型，所以上述定义从我们制定的函数名字开始。如果在类外定义成员函数，一定要使用作用域运算符指明当前函数属于哪个类！

### 7.1.5 拷贝、赋值和析构

当我们使用赋值运算符时会发生对象的赋值操作。当对象不再存在时执行销毁的操作。

#### 某些类不能依赖于合成的版本

管理动态内存的类通常不能依赖于上述操作的合成版本。

## 7.2 访问控制与封装

在 C++ 语言中，我们使用访问说明符加强类的封装性：

* 定义在 `public` 说明符之后的成员在整个程序内可以被访问，**`public` 成员定义类的接口** 。
* 定义在 `private` 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，`private` 部分封装了类的实现细节。

一个类可以包含 `0` 个或者多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符的范围直到下一个访问说明符或者类的结尾为止。

#### 使用 `class` 或者 `struct` 关键字

我们可以使用这两个关键字中的任何一个定义类。 **唯一的一点区别是，`struct` 和 `class` 的默认访问权限不一样** 。

类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式： **<u>如果我们使用 `struct` 关键字，则定义在第一个访问说明符之前的成员是 `public` ；如果使用的是 `class` 关键字，则这些成员默认是 `private` 的</u>** 。

> 使用 `class` 和 `struct` 定义类唯一的区别就是 **<u>默认的访问权限</u>** 。

### 7.2.1 友元

允许一个用户代码访问一个类的非公有成员，方法是： **令这部分用户代码成为该类的友元** 。

如果一个类想把一个函数作为它的友元，只需要添加一条以 `friend` 关键字开始函数声明语句即可：

```C++
class Sales_data
{
friend Sales_data add (const Sales_data& lhs, const Sales_data& rhs);
// ...
};
```

**<u>友元声明只能出现在类的内部，但是在类内出现的具体位置不限</u>** 。因为友元不是类的成员，也不受它所在区域访问控制级别的约束。

> 一般来说，**最好在类定义开始或者结束前的位置集中声明友元** 。

封装的优点：

* 确保用户代码不会无意间破坏封装对象的状态。
* 被封装的具体实现细节可以随时改变，而无需调整用户级别的代码。
* 防止因为用户的原因造成数据被破坏。

#### 友元的声明

**<u>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明</u>** 。也就是说，友元仅仅是通知一个类，一个函数能直接访问你的私有成员。如果我们希望类的用户能够调用某个友元函数，那么我们就 **必须在友元声明之外再专门对函数进行一次声明** !

为了使友元对类的用户可见，通常把友元的声明与类本身放置在同一个头文件中（类的外部）。

再次强调：**<u>必须在类的外部提供一个友元函数的独立声明</u>** 。

## 7.3 类的其他特性

### 7.3.1 类成员再探

为了展示新的特性，我们需要定义一对相互关联的类：`Screen` 和 `Window_mgr` 。

#### 定义一个类型成员

`Screen` 表示显示器中的一个窗口。每个 `Screen` 包含一个用于保存 `Screen` 内容的 `string` 成员和三个 `string::size_type` 类型的成员，它们分别表示光标的位置以及该窗口的高和宽。

类中还可以使用 `typedef` 关键字定义类型的别名。这个别名也可以设置访问权限。

```C++
class Screen
{
public:
    typedef std::string::size_type pos; // 用户可以使用这个别名
    // 这里也可以写作：
    // using pos = std::string::size_type;
private:
    pos cursor = 0;
    pos height = 0;
    pos width = 0;
    std::string contents;
};
```

用来定义类型的成员必须先定义后使用。因此，类型成员通常出现在类开始的地方。

#### `Screen` 类的成员函数

添加构造函数使用户能定义窗口的尺寸和内容，以及其他两个成员，分别负责移动光标和读取给定位置的字符：

```C++
class Screen
{
public:
    typedef std::string::size_type pos;
    Screen() = default; // 这里我们显式的指定需要默认构造函数
    Screen(pos ht, pos wd, char c) : // 设定高和宽，然后将高乘以宽数量的指定字符存入字符串里
        height(ht), width(wd), contents(ht * wd, c) { }
    char get() const { return contents[cursor]; }
    inline char get(pos ht, pos wd) const; // 获取坐标为ht，wd的字符
    Screen& move(pos r, pos c); // 移动窗口
private:
    pos cursor = 0;
    pos height = 0;
    pos width = 0;
    std::string contents { "" };
};
```

#### 令成员作为内联函数

一些规模较小的函数适合于被声明成内联函数。定义在类内部的成员函数是自动inline的。

当然，我们也能在类的外部使用inline关键字来修饰函数得定义。

```C++
class Screen {
public:
    typedef std::string::size_type pos;
    Screen() = default; // 这里我们显式的指定需要默认构造函数
    Screen(pos ht, pos wd, char c) : // 设定高和宽，然后将高乘以宽数量的指定字符存入字符串里
        height(ht), width(wd), contents(ht * wd, c) { }
    char get() const { return contents[cursor]; }
    inline char get(pos ht, pos wd) const; // 获取坐标为ht，wd的字符
    Screen& move(pos r, pos c); // 移动窗口
private:
    pos cursor { 0 };
    pos height { 0 };
    pos width { 0 };
    std::string contents { "" };
};

inline // 这里显式的声明为内联函数
Screen& Screen::move(pos r, pos c)
{
    pos row = r * width;
    corsor = row + c;
    return *this;
}

char Screen::get(pos r, pos c) const
{
    pos row = r * width;
    return contents[row + c];
}
```

> `inline` 成员函数应当与类定义在同一个头文件中。

#### 重载成员函数

成员函数也可以被重载，只要函数之间在参数的数量和（或）类型上有所区别就行。

#### 可变数据成员

如果希望修改类的某个数据成员，即使是在一个 `const` 成员函数内。可以通过在该变量声明中加入 `mutable` 关键字。

一个可变数据成员永远不会是 `const` ，即使它包含在 `const` 对象中。因此，一个 `const` 成员函数可以改变一个可变成员的值。

#### 类数据成员的初始值

现在开始定义一个窗口管理类并用它表示显示器上的一组 `Screen` 。这个类将包含一个 `Screen` 类型的 `vector` ，每个元素表示一个特定的 `Screen` 。

```C++
class Window_mgr
{
private:
    // 至少要有一个窗口可以进行管理
    std::vector<Screen> screens { Screen(24, 80, ' ') };    
};
```

**<u>类内初始值必须使用赋值运算符的初始化形式，或者花括号括起来的直接初始化形式</u>** 。

### 7.3.2 返回 `*this` 的成员函数

我们来编写一些函数，它们负责设置光标所在位置的字符或者其他任一给定位置的字符：

```C++
class Screen
{
public:
    inline Screen& set(char ch); // 不指定位置，以当前位置为指定位置
    inline Screen& set(pos h, pos w, char ch); // 指定位置
};

inline Screen& set(char ch)
{
    contents[cursor] = ch;
    return *this;
}

inline Screen& set(pos r, pos c, char ch)
{
    contents[r * width + c] = ch;
    return *this;
}
```

返回调用者对象的引用的好处就是可以编写链式调用的代码：

```C++
myScreen.move(4, 0).set('#');
```
即：把光标先移动到 `(4，0)` 然后再将其设置为字符 `#` 。调用运算符是 **左结合** 的。

#### 从 `const` 成员函数返回 `*this`

现在我们添加一个名为 `display` 的操作，它负责打印 `Screen` 的内容。这个函数也应当返回执行它的对象的引用。

这里存在一个问题，**<u>当一个 `const` 成员函数以引用的形式返回当前对象，那么其返回类型为常量引用</u>** 。

#### 基于 `const` 的重载

通过区分成员函数是否是 `const` 的，我们也可以对其重载。这是因为 **常量对象是不能调用非常量成员函数的** ，所以常量的对象会自动调用常量版本的成员函数。

#### 建议：对于公共代码使用私有功能函数

* 一个基本的的愿望是避免在多处使用相同的代码。
* 我们预期随着类的规模发展， `display` 函数有可能变得更加复杂，此时，把相应的操作写在一处而非两处的作用就比较明显了。
* 如果增加调试信息，只需要在私有功能中添加即可，免去了更多的麻烦。
* 额外的函数调用不会增加或者很少增加任何的开销。

### 7.3.3 类类型

每个类定义了唯一的类型。对于两个类来说，即使他们的成员完全一样，这两个类也是两个不同的类型。

> 即使两个类的成员列表完全已知，它们也是不同的类型。对于一个类来说，它的成员和其他任何类（或者其他任何作用域）的成员都不是一回事。

#### 类的声明

我们可以仅仅声明类而暂时不定义它：

```C++
class Screen; // 仅仅声明
```

这种声明被称作 **向前声明** ，它向程序中引入了名字 `Screen` 并且指明 `Screen` 是一种类型。对于这种声明后的类型来说，在它 **声明后定义前** 是一个 **不完全类型** ，也就是说，此时我们已知 `Screen` 是一个类类型，但是不清楚它包含哪些成员。

不完全类型只能在非常有限的情境下使用： **可以定义指向这种类型的指针或者引用，也可以声明以不完全类型作为参数或者返回类型函数** 。

> **一个类在创建对象前必须被定义过** ！

### 7.3.4 友元再探

类还可以把 **其他的类** 定义成友元，也可以把 **其他类（已定义）的成员函数** 定义成友元。 **友元函数能定义在类的内部，这样的函数是隐式内联的** 。

#### 类之间的友元关系

现在我们的 `Window_mgr` 添加一个名为 `clear` 的成员函数，它负责把一个指定的 `Screen` 的内容都设为空白。这时 `Window_mgr::clear` 就需要访问 `Screen` 的私有成员了。所以这里， `Screen` 就需要把 `Window_mgr` 设置为它的友元：

```C++
class Screen {
friend class Window_mgr; // 这样Window_mgr类的成员就可以访问Screen类的私有成员
// ...
};
```

> **每个类负责控制自己的友元或者友元函数** 。

#### 令成员函数作为友元

上个部分是将整个类设置为友元，现在我们还可以只为 `clear` 函数提供访问权限。当把一个成员函数声明成友元时，我们 **必须明确指出该成员函数属于那个类** ：

```C++
class Screen {
// Window_mgr::clear必须在Screen类之前被声明！
friend void Window_mgr::clear(int screen_index);
// ...
};
```

这里注意： **要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系** 。在以上的例子中，我们必须按照如下的方式设计程序：

* 首先声明并且定义 `Window_mgr` 类，其中必须声明 `clear` 函数，但是不能定义它。因为在 `clear` 定义和使用 `Screen` 的成员之前必须先声明 `Screen` 。
* 接下来声明并且定义 `Screen` 类，包括对于 `clear` 的友元声明。
* 最后定义 `clear` ，此时它才能使用 `Screen` 的成员。

#### 函数重载和友元

如果一个类想把一组重载函数声明成它的友元，它 **需要对这组函数中的每一个分别声明** 。

#### 友元声明和作用域

即使我们仅仅是用声明友元的类的成员调用该友元函数，他也必须是被声明过的。

## 7.4 类的作用域

在类的作用域外，普通的数据和成员函数只能由对象、引用或者指针使用成员运算符来访问。对于类类型成员则使用作用域运算符来访问。

#### 作用域和定义在类外部的成员

**一个类就是一个作用域** ，当我们在类的外部要使用类内定义的无论是 **变量** ， **函数** 或者 **类型** 时，都要 **使用作用域运算符来指定特定的类** 。

### 7.4.1 名字查找与类的作用域

名字查找的过程比较直接：

* 首先，在 **名字所在的块** 中寻找其声明语句，只考虑在名字的使用之前出现的声明。
* 如果没找到，继续查找 **外层作用域** 。
* 如果最终没有找到匹配声明，则程序 **报错** 。

对于定义在类内部的成员来说，类的定义分两步处理：

* 首先，编译 **成员的声明** 。
* 直到类全部可见之后才开始编译 **函数体** 。

> **<u>编译器处理完类中的全部声明后才会处理成员函数的定义</u>** 。

#### 用于类成员声明的名字查找

声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。

#### 类名要特殊处理

内层作用域的定义可以覆盖定义在外层作用域的名字，即使外层的名字已经在内层使用过。然而在类中， **如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字** 。

> 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。

#### 成员定义中的普通块作用于的名字查找

**成员函数中使用的名字** 按照如下方式解析：

* 首先，在 **成员函数内** 查找该名字的声明。和前面一样，只有在 **函数使用之前出现的声明** 才会被考虑。
* 如果在成员函数内没有找到，则在 **类内** 继续查找，这时 **类的所有成员都可以被考虑** 。
* 如果类内也没找到该名字的声明，在 **成员函数定义之前的作用域** 内继续查找。

> 不建议使用其他成员的名字作为某个成员函数的参数。

#### 类作用域之后，在外围的作用域中查找

如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找。

当外层作用域中的名字被内层的隐藏，但是又需要使用，那么就需要 **显式的调用作用域运算符来获取全局变量** ：

```C++
// 不建议的写法：不要隐藏外层作用域中可能被用到的名字
#include <iostream>

int val = 10; // 1

void func(int val) // 2
{
    std::cout << val << std::endl; // 2
    std::cout << ::val << std::endl; // 1
}

int main(int argc, char const *argv[])
{
    func(45);
    return 0;
}
```

#### 在文件中名字的出现处对其进行解析

当成员函数定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还要考虑 **在成员函数定义之前的全局作用域中的声明** 。

## 7.5 构造函数再探

### 7.5.1 构造函数初始值列表

如果没有在构造函数的初始值列表中显式的初始化成员，则该成员将在 **构造函数体之前执行默认初始化** 。例如：

```C++
class Foo {
public:
    Foo(const int v, const std::string& s) {
        val = v; // 这样看似是执行的初始化，其实初始化在函数体之前已经完成
        str = s; // 现在执行的是赋值
    }

private:
    int val { 0 };
    std::string str { "" };
};
```

书上的代码和之前使用初始值列表的定义是相同的：<u>当构造函数完成后，数据成员的值相同。区别是原来的版本 **初始化** 了它的数据成员，而这个版本是对数据成员执行了 **赋值操作** 。两种方式的差异会产生什么影响依赖于数据本身</u> 。

#### 构造函数的初始值有时必不可少

如果成员是 `const` 的话，我们就 **必须使用初始值列表** 将其初始化而非赋值。

随着构造函数体开始执行，初始化就完成了，也就是说，**初始化** 这个动作是在构造函数函数体执行之前完成的。 **我们初始化 `const` 或者引用类型数据成员的唯一机会就是通过构造函数初始值** 。

> 如果成员是 `const` 、引用，或者属于某种为提供默认构造函数的类类型，我们必须通过 **构造函数初始值列表** 为这些成员提供初始值。

#### 建议：使用 构造函数初始值

**初始化** 和 **赋值** 的区别事关底层效率的问题： **前者直接初始化数据成员，后者则先初始化再赋值** 。而且一些数据成员必须被初始化。

#### 成员初始化的顺序

构造函数初始值列表只说明用于初始化成员的值，而 **不限定** 初始化的具体执行顺序。

**<u>成员的 初始化顺序 与它们在类定义中出现的顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序</u>** 。

最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某个成员初始化其他成员。

#### 默认实参和构造函数

如果一个构造函数为所有的参数都提供了默认实参，则它实际上也定义了默认构造函数。

### 7.5.2 委托构造函数

**一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程** 。或者说它把它自己的一些或者全部职责委托给了其他构造函数。

当一个构造函数委托给另一个构造函数时，受委托的构造函数的 **初始值列表** 和 **函数体** 被依次执行。也就是说，接受委托的构造函数的初始化列表和函数体先执行，执行完毕之后才会把控制权交给委托者的函数体。

### 7.5.3 默认构造函数的作用

**默认初始化** 在以下情况下发生：

* 当我们在块作用域内不使用任何初始值定义一个非静态变量或者数组时。
* 当一个类本身含有类类型的成员且使用合成的默认构造函数时。
* 当类类型的成员没有在构造函数初始值列表中显式的初始化时。

**值初始化** 在以下情况发生：

* 在数组初始化的过程中如果我们提供的初始值数量少于数组大小时。
* 当我们不使用初始值定义一个局部静态变量时。
* 当我们通过书写形如 `ClassName()` 的表达式显式的请求值初始化时。

类必须包含一个默认构造函数以便在上述情况下使用，其中大多数情况非常容易判断。

在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。

#### 使用默认构造函数

当我们想使用默认构造函数定义一个对象时，应当写成如下形式：

```C++
Class_name object_name;
```

注意：当我们写成 `Class_name object_name();` 时，我们实际上是 **声明了一个返回值为 `Class_name` ，函数名为 `object_name` 的函数** 。

### 7.5.4 隐式的类类型转换

**如果一个构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制** 。我们把这种构造函数称作 **转换构造函数** 。

> 能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。

在前面的 `Sales_data` 类中，接受 `string` 的构造函数和接受 `istream` 的构造函数分别定义了从这两种类型向 `Sales_data` 隐式转换的规则。也就是说，在需要使用 `Sales_data` 的地方，我们可以使用 `string` 或者 `istream` 作为替代。

#### 只允许一步类类型转换

编译器只会自动地执行一步类型转换。

#### 类类型转换不是总有效

#### 抑制构造函数定义的隐式转换

在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为 `explicit` 加以阻止。

#### `explicit` 构造函数只能用于直接初始化

当我们用 `explicit` 关键字声明构造函数时，它将只能以直接初始化的形式使用。而且，编译器将不会在自动转换过程中使用该构造函数。

#### 为转换显式的使用构造函数

我们可以使用 `explicit` 构造函数进行强行转换：

```C++
// 正确：实参是一个显式构造的 Sales_data 对象
item.combine(Sales_data(null_book));
// 正确：static_cast 可以使用 explicit 构造函数
item.combine(static_cast<Sales_data>(std::cin));
```

#### 标准库中含有显式构造函数的类

### 7.5.5 聚合类

聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：

* 所有成员都是 `public` 的。
* 没有定义任何构造函数。
* 没有类内初始值。
* 没有基类，也没有虚函数。

我们可以提供一个 **花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员。这里初始值的顺序必须与声明的顺序一致** 。

如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被 **值初始化** 。初始值列表的元素个数绝对不能超过类的成员数量。

### 7.5.6 字面值常量类

**`constexpr` 函数的参数和返回值必须是字面值类型** 。除了算术类型、引用和指针外，某些类也是字面值类型。和其它类不同，字面值类型的类可能含有 `constexpr` 函数成员。这样的成员必须符合 `constexpr` 函数的所有要求，他们是隐式 `const` 的。

**数据成员都是字面值类型的聚合类是字面值常量类** 。如果一个类不是聚合类，但是它符合下述要求，则它也是一个字面值常量类：

* 数据成员都必须是字面值类型。
* 类必须至少含有一个 `constexpr` 构造函数。
* 类内初始值必须是常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的 `constexpr` 构造函数。
* 类必须使用析构函数的默认版本。

#### `constexpr` 构造函数

字面值常量类的构造函数可以是 `constexpr` 函数。一个字面值常量类必须至少提供一个 `constexpr` 构造函数。

```C++
class Debug {
public:
    constexpr Debug(bool status = true) :
        hw(status), io(status), other(status) {  }
    constexpr Debug(bool _hw, bool _io, bool _other) :
        hw(_hw), io(_io), other(_other) {  }
    constexpr bool any() { return hw || io || other; }
    void set_hw(bool _hw) { hw = _hw; }
    void set_io(bool _io) { io = _io; }
    void set_other(bool _other) { other = _other; }
private:
    bool hw; // 字面值常量类中最好不要使用类内初始值
    bool io;
    bool other;
};
```

## 7.6 类的静态成员

有时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。

#### 声明静态成员

我们通过在成员的声明之前加上关键字 `static` 使得其与类关联在一起。和其他成员一样，静态成员可以是公有或者私有的。静态数据成员的类型可以是常量、引用、指针、类类型等。

类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。

类似的，静态成员函数也不与任何对象绑在一起，它们 **不包含 `this` 指针** 。静态成员函数不能声明成 `const` 的，并且也不能在 `static` 函数体内使用 `this` 指针。无论显式还是隐式。

```C++
class Account {
public:
    void calculate() { amount += amount * interest_rate; }
    static double rate() { return interest_rate; }
    static void set_rate(double new_rate);
private:
    std::string owner; // member
    double amount; // member
    static double interest_rate; // shared by all objects
    static double init_rate(); // function
};
```

#### 使用类的静态成员

我们使用 **作用域运算符** 直接访问静态成员。虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象，引用或者指针来访问静态成员。

```C++
double r 
r = Account::rate(); // 使用作用域运算符访问静态成员

Account ac1;
Account* ac2 = &ac1;
r = ac1.rate();
r = ac2->rate();
```

成员函数不通过作用域运算符就能直接使用静态成员。

#### 定义静态成员

既可以在类的内部，也可以在类的外部 **定义** 静态成员函数。 **当在类的外部定义静态成员时，不能重复 `static` 关键字，该关键字只出现在类内部的声明语句** 。

和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。 `static` 关键字则只出现在类内部的声明语句中。

```C++
void Account::set_rate(double new_rate) { interest_rate = new_rate; } 
```

因为静态数据成员不属于类的的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的， **必须在类的外部定义和初始化每个静态成员** 。一个静态数据成员只能定义一次。

**静态数据成员定义在任何函数之外** 。因此一旦被定义，就将一直存在于程序的整个生命周期中。

> 要想确保对象只定义一次，最好的办法就是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。

#### 静态成员的类内初始化

**类的静态成员不应该在类的内部初始化** 。然而，可以为静态成员提供 `const` 整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的 `constexpr` 。

#### 静态成员能用于某些场景，而普通成员不能

静态成员独立于任何对象。静态数据成员可以是不完全类型。特别的，静态数据成员的类型可以就是它所属的类的类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或者引用。

我们可以使用静态成员作为默认实参。而非静态数据成员不能作为默认实参。